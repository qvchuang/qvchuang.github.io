<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试文章加密-[test]]]></title>
    <url>%2Farchives%2F417fd41c.html</url>
    <content type="text"><![CDATA[==测试文章加密== test test test]]></content>
  </entry>
  <entry>
    <title><![CDATA[12306智能刷票、订票]]></title>
    <url>%2Farchives%2Fd1ad8916.html</url>
    <content type="text"><![CDATA[一年一度的春运又开启了，相信还有很多小伙伴没有抢到一张回家的车票。没抢到票怎么办？自己动手丰衣足食，这个项目也许能帮到你。 ps：博主用12306分流抢票软件抢到了回家的票，但是开工的票没抢到 于是便找到了大神的开源项目购票小助手折腾一番 下面是博主的折腾过程以及踩过的坑 12306购票小助手 ¶python 版本支持 2.7.10 - 2.7.15 ¶依赖库 依赖若快 (若快注册地址：http://www.ruokuai.com/login) 项目依赖包 requirements.txt 安装方法 pip install -r requirements.txt ¶项目使用说明 可以配置邮箱，可以配置可以不配置，配置邮箱的格式在yaml里面可以看到 可以配置server酱提醒（推荐）， [配置教程] (https://www.jianshu.com/p/8d10b5b9c4e3) 提交订单验证码哪里依赖打码兔，所以如果是订票遇到验证码的时候，没有打码兔是过不了的，不推荐手动，手动太慢 配置yaml文件的时候，需注意空格和遵循yaml语法格式 ¶项目开始 修改 config/ticket_config.yaml 文件，按照提示更改自己想要的信息 windows 打开 ide 或者 cmd 请用管理员身份执行 python run.py ¶目录对应说明 123456agency - cdn代理config - 项目配置damatuCode - 打码兔接口init - 项目主运行目录myException - 异常myUrllib - urllib库 ¶思路图 ¶过程中遇到的坑 1.无法安装依赖包requirements.txt 解决方法： 将项目clone下来，进到根目录，直接 pip install -r requirements.txt 2.python版本过高或过低 解决方法：安装 2.7.10 - 2.7.15 版本的python 注意Win10下python3和python2同时安装并解决pip共存问题 3.运行提示扫码平台错误：快豆不足，请充值 解决方法：登录若快充值快豆，用于自动识别扫码 不用充值太多，1元就可以用很久 ¶运行项目 python run.py 好了，接下来就坐等抢到票了 收到抢票通知后记得在30分钟内登录12306网站进行支付哦！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP测试流程梳理]]></title>
    <url>%2Farchives%2F74c76214.html</url>
    <content type="text"><![CDATA[APP测试要点梳理 链接：链接：https://pan.baidu.com/s/1mXzsYwZdM8_G8VKjrpvkog 提取码：gcfo 一、APP测试基本流程 ¶1.1 流程图 ¶1.2 测试周期 测试周期可按项目的开发周期来确定测试时间 一般测试时间为两三周（即15个工作日） 根据项目情况以及版本质量可适当缩短或延长测试时间 ¶1.3 测试资源 测试任务开始前，检查各项测试资源: --产品功能需求文档； --产品原型图； --产品效果图； --测试设备； --其他。 ¶1.4 日报及产品上线报告（内部报告机制） 1）测试人员每天需对所测项目发送测试日报。（也就是我这边有邮件通知测试项目的时候一般均属于输出测试日报） 2）测试日报所包含的内容为： \\Dell-server\网站软件app等开发\产品测试部\测试知识区域\测试文档类模板\项目测试报告邮件输出模板.doc 3）不同版本测试报告输出 二、App测试点 ¶2.1 安全测试 ¶2.1.1 软件权限 1）扣费风险：包括发送短信、拨打电话、连接网络等 2）隐私泄露风险：包括访问手机信息、访问联系人信息等 3）对App的输入有效性校验、认证、授权、敏感数据存储、数据加密等方面进行检测 4）限制/允许使用手机功能接人互联网 5）限制/允许使用手机发送接受信息功能 6）限制/允许应用程序来注册自动启动应用程序 7）限制或使用本地连接 8）限制/允许使用手机拍照或录音 9）限制/允许使用手机读取用户数据 10) 限制/允许使用手机写人用户数据 11) 检测App的用户授权级别、数据泄漏、非法授权访问等 ¶2.1.2 安装与卸载安全性 1）应用程序应能正确安装到设备驱动程序上 2）能够在安装设备驱动程序上找到应用程序的相应图标 3）是否包含数字签名信息 4）没有用户的允许, 应用程序不能预先设定自动启动 5）卸载是否安全, 其安装进去的文件是否全部卸载 6）卸载用户使用过程中产生的文件是否有提示 7）其修改的配置信息是否复原 8）卸载是否影响其他软件的功能 9）卸载应该移除所有的文件 ¶2.1.3 数据安全性 1）当将密码或其他的敏感数据输人到应用程序时, 其不会被储存在设备中, 同时密码也不会被解码 2）输人的密码将不以明文形式进行显示 3）密码, 信用卡明细, 或其他的敏感数据将不被储存在它们预输人的位置上 4）不同的应用程序的个人身份证或密码长度必需至少在4一8 个数字长度之间 5）当应用程序处理信用卡明细, 或其他的敏感数据时, 不以明文形式将数据写到其它单独的文件或者临时文件中 6）防止应用程序异常终止而又没有侧除它的临时文件, 文件可能遭受人侵者的袭击, 然后读取这些数据信息 7）当将敏感数据输人到应用程序时, 其不会被储存在设备中 8）备份应该加密, 恢复数据应考虑恢复过程的异常、通讯中断等, 数据恢复后再使用前应该经过校验 9）应用程序应考虑系统或者虚拟机器产生的用户提示信息或安全替告 10）应用程序不能忽略系统或者虚拟机器产生的用户提示信息或安全警告, 更不能在安全警告显示前,，利用显示误导信息欺骗用户，应用程序不应该模拟进行安全警告误导用户 11）在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作 12）“ 取消” 命令操作能够按照设计要求实现其功能 13）应用程序应当能够处理当不允许应用软件连接到个人信息管理的情况 14）当进行读或写用户信息操作时, 应用程序将会向用户发送一个操作错误的提示信息 15）在没有用户明确许可的前提下不损坏侧除个人信息管理应用程序中的任何内容 16）应用程序读和写数据正确 17）应用程序应当有异常保护 18）如果数据库中重要的数据正要被重写, 应及时告知用户 19）能合理地处理出现的错误 20）意外情况下应提示用户 ¶2.1.4 通讯安全性 1）在运行其软件过程中, 如果有来电、SMS、EMS、MMS、蓝牙、红外等通讯或充电时, 是否能暂停程序，优先处理通信, 并在处理完毕后能正常恢复软件, 继续其原来的功能 2）当创立连接时, 应用程序能够处理因为网络连接中断, 进而告诉用户连接中断的情况 3）应能处理通讯延时或中断 4）应用程序将保持工作到通讯超时, 进而发送给用户一个错误信息指示有连接错误 5）应能处理网络异常和及时将异常情况通报用户 6）应用程序关闭或网络连接不再使用时应及时关闭) 断开 7) HTTP、HTTPS覆盖测试 --App和后台服务一般都是通过HTTP来交互的，验证HTTP环境下是否正常； --公共免费网络环境中（如：麦当劳、星巴克等）都要输入用户名和密码，通过SSL认证来访问网络，需要对使用HTTP Client的library异常作捕获处理 ¶2.1.5 人机接口安全性 1）返回菜单总保持可用 2）命令有优先权顺序 3）声音的设置不影响应用程序的功能 4）应用程序必需利用目标设备适用的全屏尺寸来显示上述内容 5）应用程序必需能够处理不可预知的用户操作, 例如错误的操作和同时按下多个键 ¶2.2 安装、卸载测试 验证App是否能正确安装、运行、卸载以及操作过程和操作前后对系统资源的使用情况 ¶2.2.1 安装 1）软件在不同操作系统下安装是否正常 2）软件安装后的是否能够正常运行，安装后的文件夹及文件是否写到了指定的目录里 3）软件安装各个选项的组合是否符合概要设计说明 4)）软件安装向导的UI测试 5）软件安装过程是否可以取消，点击取消后，写入的文件是否如概要设计说明处理 6）软件安装过程中意外情况的处理是否符合需求（如死机，重启，断电） 7）安装空间不足时是否有相应提示 8）安装后没有生成多余的目录结构和文件 9）对于需要通过网络验证之类的安装，在断网情况下尝试一下 10）还需要对安装手册进行测试，依照安装手册是否能顺利安装 ¶2.2.2 卸载 1）直接删除安装文件夹卸载是否有提示信息 2）测试系统直接卸载程序是否有提示信息 3）测试卸载后文件是否全部删除所有的安装文件夹 4）卸载过程中出现的意外情况的测试（如死机、断电、重启 5）卸载是否支持取消功能，单击取消后软件卸载的情况 6）系统直接卸载UI测试，是否有卸载状态进度条提示 ¶2.3 UI测试 测试用户界面(如菜单、对话框、窗口和其它可规控件)布局、风格是否满足客户要求、文字是否正确、页面是否美观、文字、图片组合是否完美、操作是否友好等。 UI测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏觅功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。 ¶2.3.1 导航测试 1）按钮、对话框、列表和窗口等；或在不同的连接页面之间需要导航 2）是否易于导航，导航是否直观 3）是否需要搜索引擎 4）导航帮助是否准确直观 5）导航与页面结构、菜单、连接页面的风格是否一致 ¶2.3.2 图形测试 1）横向比较。各控件操作方式统一 2）自适应界面设计，内容根据窗口大小自适应 3）页面标签风格是否统一 4）页面是否美观 5）页面的图片应有其实际意义而要求整体有序美观 6）图片质量要高且图片尺寸在设计符合要求的情况下应尽量小 7）界面整体使用的颜色不宜过多 ¶2.3.3 内容测试 1）输入框说明文字的内容与系统功能是否一致 2）文字长度是否加以限制 3）文字内容是否表意不明 4）是否有错别字 5）信息是否为中文显示 6）是否有敏感性词汇、关键词 7）是否有敏感性图片，如：涉及版权、专利、隐私等图片 ¶2.4 功能测试 根据软件说明或用户需求验证App的各个功能实现，采用如下方法实现并评估功能测试过程： 1)采用时间、地点、对象、行为和背景五元素或业务分析等方法分析、提炼App的用户使用场景，对比说明或需求，整理出内在、外在及非功能直接相关的需求，构建测试点，并明确测试标准，若用户需求中无明确标准遵循，则需要参考行业或相关国际标准或准则。 2)根据被测功能点的特性列丼出相应类型的测试用例对其进行覆盖，如；涉及输入的地方需要考虑等价、边界、负面、异常或非法、场景回滚、关联测试等测试类型对其进行覆盖。 3)在测试实现的各个阶段跟踪测试实现与需求输入的覆盖情况，及时修正业务或需求理解错误。 ¶2.4.1 运行 1）App安装完成后的试运行，可正常打开软件 2）App打开测试，是否有加载状态进度提示 3）App打开速度测试，速度是否可观 4）App页面间的切换是否流畅，逻辑是否正确 5）注册 12345--同表单编辑页面--用户名密码长度--注册后的提示页面--前台注册页面和后台的管理页面数据是否一致--注册后，在后台管理中页面提示 6）登录 12345678910--使用合法的用户登录系统--系统是否允许多次非法的登陆，是否有次数限制--使用已经登陆的账号登陆系统是否正确处理--使用禁用的账号登陆系统是否正确处理--用户名、口令（密码）错误或漏填时能否登陆--删除或修改后的用户，原用户登陆--不输入用户口令和用户、重复点（确定或取消按钮）是否允许登陆--登陆后，页面中登陆信息--页面中有注销按钮--登陆超时的处理 7）注销 1234--注销原模块，新的模块系统能否正确处理--终止注销能否返回原模块，原用户--注销原用户，新用户系统能否正确处理--使用错误的账号、口令、无权限的被禁用的账号进行注销 ¶2.4.2 应用的前后台切换 1) APP切换到后台，再回到app，检查是否停留在上一次操作界面 2) APP切换到后台，再回到app，检查功能及应用状态是否正常，IOS4和IOS5的版本的处理机制有的不一样 3) app切换到后台，再回到前台时，注意程序是否崩溃，功能状态是否正常，尤其是对于从后台切换回前台数据有自动更新的时候 4) 手机锁屏解屏后进入app注意是否会崩溃，功能状态是否正常，尤其是对于从后台切换回前台数据有自动更新的时候 5) 当App使用过程中有电话进来中断后再切换到app，功能状态是否正常 6) 当杀掉app进程后，再开启app，app能否正常启动 7) 出现必须处理的提示框后，切换到后台，再切换回来，检查提示框是否还存在，有时候会出现应用自动跳过提示框的缺陷 8) 对于有数据交换的页面，每个页面都必需要进行前后台切换、锁屏的测试，这种页面最容易出现崩溃 ¶2.4.3 免登录 很多应用提供免登录功能，当应用开启时自动以上一次登录的用户身份来使用app 1) app有免登录功能时，需要考虑IOS版本差异 2) 考虑无网络情况时能否正常进入免登录状态 3) 切换用户登录后，要校验用户登录信息及数据内容是否相应更新，确保原用户退出 4) 根据MTOP的现有规则，一个帐户只允许登录一台机器。所以，需要检查一个帐户登录多台手机的情况。原手机里的用户需要被踢出，给出友好提示。 5) app切换到后台，再切回前台的校验 6) 切换到后台，再切换回前台的测试 7) 密码更换后，检查有数据交换时是否进行了有效身份的校验 8) 支持自动登录的应用在进行数据交换时，检查系统是否能自动登录成功并且数据操作无误 9) 检查用户主动退出登录后，下次启动app，应停留在登录界面 ¶2.4.4 数据更新 根据应用的业务规则，以及数据更新量的情况，来确定最优的数据更新方案。 1) 需要确定哪些地方需要提供手动刷新，哪些地方需要自动刷新，哪些地方需要手动+自动刷新 2) 确定哪些地方从后台切换回前台时需要进行数据更新 3) 根据业务、速度及流量的合理分配，确定哪些内容需要实时更新，哪些需要定时更新 4) 确定数据展示部分的处理逻辑，是每次从服务端请求，还是有缓存到本地，这样才能有针对性的进行相应测试 5) 检查有数据交换的地方，均有相应的异常处理。 ¶2.4.5 离线浏览 很多应用会支持离线浏览，即在本地客户端会缓存一部分数据供用户查看。 1) 在无网络情况可以浏览本地数据 2) 退出app再开启app时能正常浏览 3) 切换到后台再切回前台可以正常浏览 4) 锁屏后再解屏回到应用前台可以正常浏览 5) 在对服务端的数据有更新时会给予离线的相应提示 ¶2.4.6 App更新 1) 当客户端有新版本时，有更新提示 2) 当版本为非强制升级版时，用户可以取消更新，老版本能正常使用。用户在下次启动app时，仍能出现更新提示 3) 当版本为强制升级版时，当给出强制更新后用户没有做更新时，退出客户端。下次启动app时，仍出现强制升级提示 4) 当客户端有新版本时，在本地不删除客户端的情况下，直接更新检查是否能正常更新 5) 当客户端有新版本时，在本地不删除客户端的情况下，检查更新后的客户端功能是否是新版本 6) 当客户端有新版本时，在本地不删除客户端的情况下，检查资源同名文件如图片是否能正常更新成最新版本 ¶2.4.7 定位、照相机服务 1) App有用到相机，定位服务时，需要注意系统版本差异 2) 有用到定位服务、照相机服务的地方，需要进行前后台的切换测试，检查应用是否正常 3) 当定位服务没有开启时，使用定位服务，会友好性弹出是否允许设置定位提示。当确定允许开启定位时，能自动跳转到定位设置中开启定位服务 4) 测试定位、照相机服务时，需要采用真机进行测试 ¶2.4.8 时间测试 客户端可以自行设置手机的时区、时间，因此需要校验该设置对app的影响。 –中国为东8区，所以当手机设置的时间非东8区时，查看需要显示时间的地方，时间是否展示正确，应用功能是否正常。时间一般需要根据服务器&gt; 时间再转换成客户端对应的时区来展示，这样的用户体验比较好。比如发表一篇微博在服务端记录的是10：00，此时，华盛顿时间为22：00，客户端&gt; 去浏览时，如果设置的是华盛顿时间,则显示的发表时间即为22:00,当时间设回东8区时间时，再查看则显示为10：00。 ¶2.4.9 PUSH测试 1) 检查push消息是否按照指定的业务规则发送 2) 检查不接受推送消息时，检查用户不会再接收到push 3) 如果用户设置了免打扰的时间段，检查在免打扰时间段内，用户接收不到PUSH 在非免打扰时间段，用户能正常收到push。 4) 当push消息是针对登录用户的时候，需要检查收到的push与用户身份是否相符，没有错误地将其它人的消息推送过来。一般情况下，只对手机上最后一个登录用户进行消息推送 5) 测试push时，需要采用真机进行测试 ¶2.5 性能测试 评估App的时间和空间特性 ： 1)极限测试：在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应 123--内存满时安装App--运行App时手机断电--运行App时断掉网络 2)响应能力测试：测试App中的各类操作是否满足用户响应时间要求 。（安装包放到云测上可以测试） 12--App安装、卸载的响应时间--App各类功能性操作的影响时间 3)压力测试：反复/长期操作下、系统资源是否占用异常。（itestin） 12--App反复进行安装卸载，查看系统资源是否正常--其他功能反复进行操作，查看系统资源是否正常 4)性能评估：评估典型用户应用场景下，系统资源的使用情况。（Jmeter） ¶2.6 交叉事件测试 针对智能终端应用的服务等级划分方式及实时特性所提出的测试方法。 交叉测试又叫事件或冲突测试，是指一个功能正在执行过程中，同时另外一个事件或操作对该过程进行干扰的测试。 如；App在前/后台运行状态时与来电、文件下载、音乐收听等关键运用的交互情况测试等。 交叉事件测试非常重要，能发现很多应用中潜在的性能问题。 1） 多个App同时运行是否影响正常功能 2） App运行时前/后台切换是否影响正常功能 3） App运行时拨打/接听电话 4） App运行时发送/接收信息 5） App运行时发送/收取邮件 6） App运行时切换网络（2G、3G、wifi） 7） App运行时浏览网络 8） App运行时使用蓝牙传送/接收数据 9） App运行时使用相机、计算器等手机自带设备 ¶2.7 兼容测试 主要测试内部和外部兼容性 1）与本地及主流App是否兼容 2）基于开发环境和生产环境的不同，检验在各种网络连接下(WiFi、GSM、GPRS、EDGE、WCDMA、CDMA1x、CDMA2000、HSPDA等)，App的数据和运用是否正确 3）与各种设备是否兼容，若有跨系统支持则需要检验是否在各系统下，各种行为是否一致 123--不同操作系统的兼容性，是否适配--不同手机屏幕分辨率的兼容性--不同手机品牌的兼容性 ¶2.8 回归测试 1）Bug修复后且在新版本发布后需要进行回归测试 2）Bug修复后的回归测试在交付前、要进行全量用例的回归测试 ¶2.9 升级、更新测试 新版版发布后，配合不同网络环境的自劢更新提示及下载、安装、更新、启劢、运行的验证测试。 1）测试升级后的功能是否与需求说明一样 2）测试与升级模块相关的模块的功能是否与需求一致 3）升级安装意外情况的测试（如死机、断电、重启） 4）升级界面的UI测试 5）不同操作系统间的升级测试 ¶2.10 用户体验测试 以主观的普通消费者的角度去感知产品或服务的舒适、有用、易用、友好亲切程度。 通过不同个体、独立空间和非经验的统计复用方式去有效评价产品的体验特性有提出修改意见提升产品的潜在客户满意度。 1）是否有空数据界面设计，引导用户去执行操作 2）是否滥用用户引导 3）是否有不可点击的效果，如：你的按钮此时处于不可用状态，那么一定要灰掉，或者拿掉按钮，否则会给用户误导 4）菜单层次是否太深 5）交互流程分支是否太多 6）相关的选项是否离得很远 7）一次是否载入太多的数据 8）界面中按钮可点击范围是否适中 9）标签页是否跟内容没有从属关系，当切换标签的时候，内容跟着切换 10）操作应该有主次从属关系 11）是否定义Back的逻辑。涉及软硬件交互时，Back键应具体定义 12）是否有横屏模式的设计，应用一般需要支持横屏模式，即自适应设计 ¶2.11 硬件环境测试 ¶2.11.1 手势操作测试 1）手机开锁屏对运行中的App的影响 2）切换网络对运行中的App的影响 3）运行中的App前后台切换的影响 4）多个运行中的App的切换 5）App运行时关机 6）App运行时重启系统 7）App运行时充电 8）App运行时kill掉进程再打开 ¶2.11.2 网络环境 手机的网络目前主要分为2G、3G、wifi。目前2G的网络相对于比较慢，测试时尤其要注意此块的测试。 1) 无网络时，执行需要网络的操作，给予友好提示，确保程序不出现crash 2) 内网测试时，要注意选择到外网操作时的异常情况处理 3) 在网络信号不好时，检查功能状态是否正常，确保不因提交数据失败而造成crash。 4) 在网络信号不好时，检查数据是否会一直处于提交中的状态，有无超时限制。如遇数据交换失败时要给予提示。 5) 在网络信号不好时，执行操作后，在回调没有完成的情况下，退出本页面或者执行其他操作的情况，有无异常情况。此问题也会经常出现程序crash。 ¶2.11.3 服务器宕机或出现404、502等情况下的测试 后台服务牵涉到DNS、空间服务商的情况下会影响其稳定性，如： 当出现域名解析故障时，你对后台API的请求很可能就会出现404错误，抛出异常。 这时需要对异常进行正确的处理，否则可能会导致程序不能正常工作。 ¶2.12 接口测试 （这个一般研发来做，如下想学习的话，可以使用chrome下的postman或者 网上其他工具进行录入查看简单的测试） 服务端一般会提供JSON格式的数据给客户端，所以我们在服务端需要进行接口测试，确保服务端提供的接口并转换的JSON内容正确， 对分支、异常流有相应的返回值。此块测试可以采用itest框架进行测试。最方便的是采用httpclient进行接口测试。 进行服务端测试时，需要开发提供一份接口文档。 ¶2.13 客户端数据库测试（mysql） 1）一般的增、删、改、查测试 2） 当表不存在时是否能自动创建，当数据库表被删除后能否再自建，数据是否还能自动从服务端中获取回来并保存 3） 在业务需要从服务端取回数据保存到客户端的时候，客户端能否将数据保存到本地 4） 当业务需要从客户端取数据时，检查客户端数据存在时，app数据是否能自动从客户端数据中取出，还是仍然会从服务器端获取？检查客户端数据不存在时，app数据能否自动从服务器端获取到并保存到客户端 5） 当业务对数据进行了修改、删除后，客户端和服务端是否会有相应的更新]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>APP测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果这五件事都做不了，那你的生活早已偏离了航向]]></title>
    <url>%2Farchives%2F12b541cb.html</url>
    <content type="text"><![CDATA[本文翻译自：https://medium.com/ 原文：If You’re Too Busy For These 5 Things: Your Life Is More Off-Course Than You Think 作者：Benjamin P. Hardy 飞机在飞行的时候会因为天气原因偏离航向，但大多数时候都会准点到达目的地。 这是因为通过空中交通管制可以使飞行员不断修正航向，很容易回到正确的航道上，但如果不及时修正的话，灾难就会发生。 例如1979年,一架客机载有257人离开新西兰飞行往南极洲。快到南极洲的时候,飞行员驾驶飞机下降,这时惨烈的事情发生了 降落坐标被放置在了当地活跃的火山,厄瑞玻斯山上。火山上空的云团和雪混合在一起,让飞行员误以为那是一片平地 仪器发出警告时已经太晚了，最后机毁人亡 这次的机难事故好比我们的生活：一些小的事情决定着你能否成为想成为的那种人。 我们都想在正确的道路上不断进步，可是，如何才能知道自己目前的方向是否正确呢？ 可以问问这几个问题检视一下自己： 你在掌控自己的生活吗？ 你多久检查一次自己是否偏离航道？ 你的目的地在哪里？ 你打算什么时候到那里？ 你目前的生活偏离航向了吗？偏离多久了？ 如果你的答案是：已经偏离。 那么可以做这五件事让生活回归到原本的方向上。 ¶一、组织你的生活 没有人比你更在意自己的成功，所以要在前进的道路上跑起来，必须组织好自己的生活。 史蒂芬·柯维在《高效能人士的7个习惯》中解释到：有些事情是重要的，有些事情是紧急的。大多数人喜欢先做紧急的事情，这些事情被称为“浅”活&gt; &gt; 动，（如：回答电子邮件，这些只是日常的东西）。很少有人会先做重要事情，这些事被称为“深”活动，（如：学习、关注身体健康、维护人际关系、&gt; 旅游和制定目标）。生活是非常忙碌的，很难保持一切都井井有条，那么科学的安排自己的生活就显得格外重要。 想要组织好自己的生活呢，可以试着从这几个方面改善： ¶生活环境 好的环境能让然保持愉悦的心情，也可以让人刚放松。如果你的生活空间混乱不堪 闲置的东西非常多，车子就像堆在车库的杂物...... 这样的生活环境是在影响你的精力，让你失去能量 ¶财务状况 如果你有一些不必要的债务，对理财一无所知，不记录自己的收入和支出，那你的财务状况不是很乐观 当你开始记录自己的资金情况时，会发现之前有很多不必要的花销 ¶人际关系 人际关系并不需要特地去维护，但人人都希望有更好的人际关系 待人真诚是人际关系中的第一要素 在交际过程中，如果能让彼此的生活变得更有意义就更好了 ¶健康状况 你应该经常反省自己是不是容易把健康问题放在一边 你能意识到身体对食物的需求吗？你的身材是你想要吗？你现在的健康比三个月前好还是差？ 不重视健康状况的话，得到再多的成就也是徒劳 ¶精神世界 事实证明死亡并不是我们最大的恐惧，最大的恐惧是在死的时候还没有过上想要的生活 所以当你就清楚想要的生活是什么、知道自己为什么而活时，就会知道要如何度过每一天 ¶时间意识 你能掌控自己的时间吗？ 当你开始有时间意识，时间就会慢下来，你会有时间做更多想做的事情 你能控制自己的时间了，而不是被时间控制。这是一件很神奇的事情 假如生活是一个花园，在种下各种植物后需要施肥和除草，组织自己的生活也是这个道理 ¶二、计划和投资你的未来 ¶学会计划未来 中国谚语里有一句话：种一棵树最好的时间是二十年前，其次就是现在 人们很少有意识地计划和设计自己的生活，但把这些基本生活领域的事情整理好，对创造你的未来是很重要的 很多人喜欢这么计划自己的未来： 二十年后成为什么样的人。这种长期大型的目标实际上会减慢你的行动效率 把这种长期大型目标细化，分成小块，例如最近3-6个月内要完成什么，达到什么目标 这样下来既可以总结自己的计划，又方便调整前进的方向 ¶学会投资自己 想投资自己的未来让自己变得更强，就要放弃短暂的满足感，大多数人都做不到这一点 因为大家很容易只顾及眼前的利益，没有对自己未来的财务状况、健康情况和时间做投资 但是当你开始投资未来的自己时，生活会离你想象得更进一步 ¶三、跟进和评估 如果不会跟进和评估自己，盲目的组织生活和投资未来也是白费力气 研究一再发现，对行为跟进和评估后，会有大幅度提高 一旦你学会组织现状，制定计划，并开始跟踪，你的生活就会迅速发生变化 跟进自己的重要指标可以从以下几个方面考虑： 个人跟踪的区域（如目标，不应该有太多） 我的收入和花费 每个月新结识的朋友 我的首要任务 我对时间的分配 在做这些事情的时候，思想会发生改变，不仅能增强自信心，控制事情的能力也会提高 生活反而会变得更简单，整个人也会变得更自由 ¶四、用冥想来减弱误导的声音 我们生活的环境中有太多声音，一些错误的声音会误导我们去向错误的地方，这样只会加速失败 正如托马斯·默顿所说“人可能一辈子都在攀登成功的阶梯，却发现到达顶峰的时候，梯子靠在了错误的墙壁上。”这种事情常常发生。最后我们会意识&gt; &gt; 到，那些正在疯狂追求的是别人的目标，不是我们自己的。 留一些时间给冥想用来清空自己 在没有思路或者事情无法进展的时候，试着让自己安静下来沉思，新的理解和火花会在这时候迸发 ¶五、每天都朝着你的目标前进 “问：你有多少天没向着自己的目标前进了？ 答：好多天了。因为生活太忙碌。” 如果不能腾出时间来改善自己，调整目前的状态，就会迷失在忙碌的生活中 持续下去的话，在成为期望的那个自己之前你就会枯萎，而且不知道时间去哪里了 如果你已经开始对自己的生活进行组织、计划，并且定时评估和反省 养成冥想的习惯，对躁动不安的状态采取适当的处理方法 把每天进步一点点作为小的目标，你会意识到那些宏大的目标并不是很遥远 ¶结论 生活就像飞机航行那样，很容易偏离航向，我们需要及时修正 通过组织自己的生活，规划未来和调整进展方式等来修正航向，提高自己 这样坚持一段时间，你会为自己的改变感到震惊 现在就开始行动吧！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-内置函数和匿名函数]]></title>
    <url>%2Farchives%2Fb2fd9b25.html</url>
    <content type="text"><![CDATA[¶一、内置函数 python一共为我们提供了68个内置函数。它们就是python提供给你直接可以拿来使用的所有函数。 →内置函数思维导图 ¶常用内置函数方法 1、print 输出 12345print('666',end='')print('666')print(1,2,3,4,5,sep='|')6666661|2|3|4|5 2、input 输入 12s = input("请输入内容 ： ") #输入的内容赋值给s变量print(s) #输入什么打印什么。数据类型是str 3、type(o) 返回变量o的数据类型 4、dir–查找对象的所有方法 dir() 默认查看全局空间内的属性，也接受一个参数，查看这个参数内的方法或变量 12print(dir(list)) #查看列表的内置方法print(dir(int)) #查看整数的内置方法 5、locals()获取执行本方法所在命名空间内的局部变量的字典 globals()获取全局变量的字典 12345def func(): name = 'alex' print(locals()) print(globals())func() 6、help（）----将你查询的对象所有信息都拿出来 help（list）–可以吧列表的所有用法信息都输出出来 7、abs（）----取绝对值 print(abs(-1)) print(abs(1)) def func(ret): print(44) 最大值 ret = max(1,2,-3,key=abs) print(ret)------ -3 #最小值 ret = min([1,2,3]) print(ret)------ 1 #sum iterable,初始值 ret = sum([1,2,3],10) print(ret)------ 16 8、callable---- 判断此变量是不是函数名 123def func():passprint(callable(func)) #参数是函数名，可调用，返回Trueprint(callable(123)) #参数是数字，不可调用，返回False 9、id(o) o是参数，返回一个变量的内存地址 10、hash()-----通过哈希表的规则,将对象转换成哈希值 hash(o) o是参数，返回一个可hash变量的哈希值，不可hash的变量被hash之后会报错。 12345678t = (1,2,3)l = [1,2,3]print(hash(t)) #可hashprint(hash(l)) #会报错'''结果：TypeError: unhashable type: 'list'''' hash函数会根据一个内部的算法对当前可hash变量进行处理，返回一个int数字。 *每一次执行程序，内容相同的变量hash值在这一次执行过程中不会发生改变。 11 、all（）----可迭代对象里面的所有的值转化成bool值如果都是True则,返回True 12print(all([1,2,3,0]))False 12、十进制与二进制十六进制转化 十进制转化成二进制 print(bin(100))--------------0b1100100 #将十进制转化成八进制 print(oct(9))-----------------0o11 #将十进制转化成十六进制 print(hex(33))--------------0x21 13、float（）----数据类型中浮点 有限小数,无线循环小数,不包含(无线不循环小数) 1234print(1.35432,type(1.35432))print(float(3))1.35432 &lt;class 'float'&gt;3.0 14、enumerate (iterable,start 起始值) 枚举 123456789101112l = ['手机','电话','充气娃娃',]for i in enumerate(l,1): print(i)(1, '手机')(2, '电话')(3, '充气娃娃')l = ['手机','电话','充气娃娃',]for k,v in enumerate(l,1): print(k,v)1 手机2 电话3 充气娃娃 15、eval（） 有返回值 除去字符串两边的引号,返回里面的内容 exec（） 没有返回值 除去字符串两边的引号,执行里面的代码 两者区别： 12345678s = "&#123;'name':'alex'&#125;"s1 = "1+2+3+4"print(eval(s),type(eval(s)))print(exec(s),type(exec(s)))print(eval(s1),type(eval(s1))) # &#123;'name': 'alex'&#125; &lt;class 'dict'&gt; # None &lt;class 'NoneType'&gt; # 10 &lt;class 'int'&gt; 1234567891011121314code = '''for i in range(10): print(i)'''print(exec(code))0123456789None 16、ord（） 输入字符返回Unicode对应的编码位置 123456print(ord('a'))print(ord('b'))print(ord('中'))979820013 17、chr（）输入编码位置返回Unicode对应的字符 1234print(chr(97))print(chr(20013))a中 18、max（）里面可以加函数，以函数规则返回最大值 12345678910dic = &#123;'k1':20,'k2':30,'k3':100&#125;def func(x): return dic[x]l1 = max(dic,key=func,)print(l1) #k3dic = &#123;3:20,2:30,1:100&#125;def func(x): return xl1 = max(dic,key=func,)print(l1) #3 19、open() 打开一个文件，返回一个文件操作符(文件句柄) 操作文件的模式有r,w,a,r+,w+,a+ 共6种 每一种方式都可以用二进制的形式操作(rb,wb,ab,rb+,wb+,ab+) 可以用encoding指定编码. 20、__import__导入一个模块 123import timeos = __import__('os')print(os.path.abspath('.')) ¶重点掌握 其他：input,print,type,hash,open,import,dir str类型代码执行：eval,exec 数字：bool,int,float,abs,divmod,min,max,sum,round,pow 序列——列表和元组相关的：list和tuple 序列——字符串相关的：str，bytes，repr 序列：reversed，slice 数据集合——字典和集合：dict，set，frozenset 数据集合：len，sorted，enumerate，zip，filter，map ¶二、匿名函数 匿名函数：为了解决那些功能很简单的需求而设计的一句话函数 1234567 #这段代码def calc(n): return n**nprint(calc(10)) #换成匿名函数calc = lambda n:n**nprint(calc(10)) 上面是对calc这个匿名函数的分析，下面给出了一个关于匿名函数格式的说明 1234函数名 = lambda 参数 ：返回值 #参数可以有多个，用逗号隔开 #匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值 #返回值和正常的函数一样可以是任意数据类型 可以看出，匿名函数并不是真的不能有名字 匿名函数的调用和正常的调用也没有什么分别。 就是 函数名(参数) 就可以了～～～]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-迭代器与生成器]]></title>
    <url>%2Farchives%2F7c18a91b.html</url>
    <content type="text"><![CDATA[¶一、迭代器 ¶python中的for循环 要了解for循环是怎么回事儿，还是要从代码的角度出发。 首先，对一个列表进行for循环。 12for i in [1,2,3,4]: print(i) 上面这段代码肯定是没有问题的，但是我们换一种情况，来循环一个数字1234试试 1234567for i in 1234 print(i) 结果：Traceback (most recent call last): File "test.py", line 4, in &lt;module&gt; for i in 1234:TypeError: 'int' object is not iterable 报错了！ “TypeError: ‘int’ object is not iterable” 说int类型不是一个iterable，那这个iterable是什么？ iterable 可迭代的;可重复的;迭代的 ¶迭代和可迭代协议 ¶什么是迭代 现在，我们已经知道有一个叫做“可迭代的”概念。 首先，从报错来分析，好像之所以1234不可以for循环，是因为它不可迭代。 那么如果“可迭代”，就应该可以被for循环了。 字符串、列表、元组、字典、集合都可以被for循环，说明他们都是可迭代的。 怎么来证明这一点呢？ from collections import Iterable l = [1,2,3,4] t = (1,2,3,4) d = {1:2,3:4} s = {1,2,3,4} print(isinstance(l,Iterable)) print(isinstance(t,Iterable)) print(isinstance(d,Iterable)) print(isinstance(s,Iterable)) 结合使用for循环取值的现象，再从字面上理解一下， 其实迭代就是，可以将某个数据集内的数据“一个挨着一个的取出来”，就叫做迭代。 ¶可迭代协议 现在从结果分析原因，能被for循环的就是“可迭代的”，但是如果正着想，for怎么知道谁是可迭代的呢？ 假如我们自己写了一个数据类型，希望这个数据类型里的东西也可以使用for被一个一个的取出来， 那我们就必须满足for的要求。这个要求就叫做“协议”。 可以被迭代要满足的要求就叫做可迭代协议。 可迭代协议的定义非常简单，就是内部实现了__iter__方法。 接下来就来验证一下： 1234print(dir([1,2]))print(dir((2,3)))print(dir(&#123;1:2&#125;))print(dir(&#123;1,2&#125;)) 结果: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index'] ['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] ['__and__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__iand__', '__init__', '__ior__', '__isub__', '__iter__', '__ixor__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__xor__', 'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update'] 总结一下：可以被for循环的都是可迭代的，要想可迭代，内部必须有一个__iter__方法。 接着分析，__iter__方法做了什么事情呢？ print([1,2].__iter__()) 结果 &lt;list_iterator object at 0x1024784a8&gt; 执行了list([1,2])的__iter__方法，得到了一个list_iterator， 现在又得到了一个新名词——iterator。 iterator 迭代器，迭代程序 iterator,是一个计算机中的专属名词，叫做迭代器 ¶迭代器协议 知道“可迭代”之后，那么什么叫“迭代器”？ 虽然不知道什么叫迭代器，但是现在已经有一个迭代器了，这个迭代器是一个列表的迭代器。 先来看看这个列表的迭代器比起列表来说实现了哪些新方法，这样就能揭开迭代器的神秘面纱了 ''' dir([1,2].__iter__())是列表迭代器中实现的所有方法，dir([1,2])是列表中实现的所有方法,都是以列表的形式返回给我们的，为了看的更清楚，我们分别把他们转换成集合， 然后取差集。 ''' #print(dir([1,2].__iter__())) #print(dir([1,2])) print(set(dir([1,2].__iter__()))-set(dir([1,2]))) 结果： {'__length_hint__', '__next__', '__setstate__'} 在列表迭代器中多了三个方法，那么这三个方法都分别做了什么事呢？ ter_l = [1,2,3,4,5,6].__iter__() #获取迭代器中元素的长度 print(iter_l.__length_hint__()) #根据索引值指定从哪里开始迭代 print('*',iter_l.__setstate__(4)) #一个一个的取值 print('**',iter_l.__next__()) print('***',iter_l.__next__()) 这三个方法中，能让我们一个一个取值的神奇方法就是__next__ 在for循环中，就是在内部调用了__next__方法才能取到一个一个的值。 接下来就用迭代器的next方法来写一个不依赖for的遍历。 123456789101112l = [1,2,3,4]l_iter = l.__iter__()item = l_iter.__next__()print(item)item = l_iter.__next__()print(item)item = l_iter.__next__()print(item)item = l_iter.__next__()print(item)item = l_iter.__next__()print(item) 这是一段会报错的代码，如果我们一直取next取到迭代器里已经没有元素了， 就会抛出一个异常StopIteration，告诉我们，列表中已经没有有效的元素了。 这个时候，就要使用异常处理机制来把这个异常处理掉。 12345678l = [1,2,3,4]l_iter = l.__iter__()while True: try: item = l_iter.__next__() print(item) except StopIteration: break 现在就是使用while循环实现了原本for循环做的事情，这个l.__iter__()就是一个迭代器。 迭代器遵循迭代器协议：必须拥有__iter__方法和__next__方法。 print('__next__' in dir(range(12))) #查看'__next__'是不是在range()方法执行之后内部是否有__next__ print('__iter__' in dir(range(12))) #查看'__next__'是不是在range()方法执行之后内部是否有__next__ from collections import Iterator print(isinstance(range(100000000),Iterator)) #验证range执行之后得到的结果不是一个迭代器 ¶二、生成器 ¶初识生成器 我们知道的迭代器有两种： 一种是调用方法直接返回的，一种是可迭代对象通过执行iter方法得到的 迭代器有的好处是可以节省内存。 如果在某些情况下，我们也需要节省内存,就只能自己写。 我们自己写的这个能实现迭代器功能的东西就叫生成器。 Python中提供的生成器： 1.生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行 2.生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表 生成器Generator： 本质：迭代器(所以自带了__iter__方法和__next__方法，不需要我们去实现) 特点：惰性运算,开发者自定义 ¶生成器函数 一个包含yield关键字的函数就是一个生成器函数。 yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。 1234567891011121314import timedef genrator_fun1(): a = 1 print('现在定义了a变量') yield a b = 2 print('现在又定义了b变量') yield bg1 = genrator_fun1()print('g1 : ',g1) #打印g1可以发现g1就是一个生成器print('-'*20) #我是华丽的分割线print(next(g1))time.sleep(1) #sleep一秒看清执行过程print(next(g1)) 生成器有什么好处呢？就是不会一下子在内存中生成太多数据 假如我想让工厂给学生做校服，生产2000000件衣服，我和工厂一说，工厂应该是先答应下来，然后再去生产，我可以一件一件的要，也可以根据学生一批一批的找工厂拿。而不能是一说要生产2000000件衣服，工厂就先去做生产2000000件衣服，等回来做好了，学生都毕业了。。。 #初识生成器二 def produce(): &quot;&quot;&quot;生产衣服&quot;&quot;&quot; for i in range(2000000): yield &quot;生产了第%s件衣服&quot;%i product_g = produce() print(product_g.__next__()) #要一件衣服 print(product_g.__next__()) #再要一件衣服 print(product_g.__next__()) #再要一件衣服 num = 0 for i in product_g: #要一批衣服，比如5件 print(i) num +=1 if num == 5: break #到这里我们找工厂拿了8件衣服，我一共让我的生产函数(也就是produce生成器函数)生产2000000件衣服。 #剩下的还有很多衣服，我们可以一直拿，也可以放着等想拿的时候再拿 ¶更多应用 生成器监听文件输入的例子 import time def tail(filename): f = open(filename) f.seek(0, 2) #从文件末尾算起 while True: line = f.readline() # 读取文件中新的文本行 if not line: time.sleep(0.1) continue yield line tail_g = tail('tmp') for line in tail_g: print(line) ¶send def generator(): print(123) content = yield 1 print('=======',content) print(456) yield2 g = generator() ret = g.__next__() print('***',ret) ret = g.send('hello') #send的效果和next一样 print('***',ret) #send 获取下一个值的效果和next基本一致 #只是在获取下一个值的时候，给上一yield的位置传递一个数据 #使用send的注意事项 # 第一次使用生成器的时候 是用next获取下一个值 # 最后一个yield不能接受外部的值 计算移动平均值(1) def averager(): total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/count g_avg = averager() next(g_avg) print(g_avg.send(10)) print(g_avg.send(30)) print(g_avg.send(5)) 计算移动平均值(2)_预激协程的装饰器 def init(func): #在调用被装饰生成器函数的时候首先用next激活生成器 def inner(*args,**kwargs): g = func(*args,**kwargs) next(g) return g return inner @init def averager(): total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/count g_avg = averager() # next(g_avg) 在装饰器中执行了next方法 print(g_avg.send(10)) print(g_avg.send(30)) print(g_avg.send(5)) ¶yield from def gen1(): for c in 'AB': yield c for i in range(3): yield i print(list(gen1())) def gen2(): yield from 'AB' yield from range(3) print(list(gen2())) ¶列表推导式和生成器表达式 egg_list=['鸡蛋%s' %i for i in range(10)] #列表解析 laomuji=('鸡蛋%s' %i for i in range(10))#生成器表达式 print(laomuji) print(next(laomuji)) #next本质就是调用__next__ print(laomuji.__next__()) print(next(laomuji)) 总结： 1.把列表解析的[]换成()得到的就是生成器表达式 2.列表解析与生成器表达式都是一种便利的编程方式，只不过生成器表达式更节省内存 3.Python不但使用迭代器协议，让for循环变得更加通用。大部分内置函数，也是使用迭代器协议访问对象的。 例如， sum函数是Python的内置函数，该函数使用迭代器协议访问对象，而生成器实现了迭代器协议， 所以，我们可以直接这样计算一系列值的和： sum(x ** 2 for x in range(4)) 而不用多此一举的先构造一个列表： sum([x ** 2 for x in range(4)]) ¶三、小结 可迭代对象： 拥有__iter__方法 特点：惰性运算,例如:range(),str,list,tuple,dict,set 迭代器Iterator： 拥有__iter__方法和__next__方法 生成器Generator： 本质：迭代器，所以拥有__iter__方法和__next__方法 特点：惰性运算,开发者自定义 使用生成器的优点： 1.延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。 1234 #列表解析sum([i for i in range(100000000)])#内存占用大,机器容易卡死 #生成器表达式sum(i for i in range(100000000))#几乎不占内存 2.提高代码可读性]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-装饰器函数]]></title>
    <url>%2Farchives%2F7af05b52.html</url>
    <content type="text"><![CDATA[¶阅读目录 装饰器的形成过程 开放封闭原则 装饰器主要功能和装饰器固定结构 带参数的装饰器 多个装饰器装饰一个函数 ¶装饰器的形成过程 ¶装饰器——简单版 1234567891011import timedef func1(): print('in func1')def timer(func): def inner(): start = time.time() func() print(time.time() - start) return innerfunc1 = timer(func1)func1() ¶装饰器——语法糖 1234567891011import timedef timer(func): def inner(): start = time.time() func() print(time.time() - start) return inner@timer #==&gt; func1 = timer(func1)def func1(): print('in func1')func1() 可以简单的总结一下： 装饰器的本质：一个闭包函数 装饰器的功能：在不修改原函数及其调用方式的情况下对原函数功能进行扩展 ¶装饰器——带参数的装饰器 12345678910def timer(func): def inner(a): start = time.time() func(a) print(time.time() - start) return inner@timerdef func1(a): print(a)func1(1) ¶通用装饰器 import time def timer(func): def inner(*args,**kwargs): start = time.time() re = func(*args,**kwargs) print(time.time() - start) return re return inner @timer #==&gt; func1 = timer(func1) def func1(a,b): print('in func1') @timer #==&gt; func2 = timer(func2) def func2(a): print('in func2 and get a:%s'%(a)) return 'fun2 over' func1('aaaaaa','bbbbbb') print(func2('aaaaaa')) 1234567def wrapper(func): def inner(*args,**kwargs): '''执行函数前操作''' ret = func(*args,**kwargs) '''执行函数后的操作''' return ret return inner ¶装饰器——带返回值的装饰器 import time def timer(func): def inner(*args,**kwargs): start = time.time() re = func(*args,**kwargs) print(time.time() - start) return re return inner @timer #==&gt; func2 = timer(func2) def func2(a): print('in func2 and get a:%s'%(a)) return 'fun2 over' func2('aaaaaa') print(func2('aaaaaa')) ¶查看函数信息的一些方法 12345def index(): '''这是一个主页信息''' print('from index')print(index.__doc__) #查看函数注释的方法print(index.__name__) #查看函数名的方法 ¶ 装饰器——wraps demo from functools import wraps def deco(func): @wraps(func) #加在最内层函数正上方 def wrapper(*args,**kwargs): return func(*args,**kwargs) return wrapper @deco def index(): '''哈哈哈哈''' print('from index') print(index.__doc__) #document(文档) print(index.__name__) #查看字符串格式的函数名 ¶开放封闭原则 1.对扩展是开放的 为什么要对扩展开放呢？ 任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 2.对修改是封闭的 为什么要对修改封闭呢？ 因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。 装饰器完美的遵循了这个开放封闭原则 ¶装饰器的主要功能和装饰器的固定结构 装饰器的主要功能： 在不改变函数调用方式的基础上在函数的前、后添加功能。 装饰器的固定格式： 12345678 #装饰器的固定格式def wrapper(f): #装饰器函数，f是被装饰的函数 def inner(*args,**kwargs): '''在被装饰函数之前要做的事''' ret = f(*args,**kwargs) #被装饰的函数 '''在被装饰函数之后要做的事''' return ret return inner 1234567 #装饰器的固定格式——wraps版from functools import wrapsdef deco(func): @wraps(func) #加在最内层函数正上方 def wrapper(*args,**kwargs): return func(*args,**kwargs) return wrapper ¶带参数的装饰器 FLAGE = True def outer(flag): def timer(func): def inner(*args,**kwargs): if flag: print('''执行函数之前要做的''') re = func(*args,**kwargs) if flag: print('''执行函数之后要做的''') return re return inner return timer @outer(FLAGE) def func(): print(111) @outer(FLAGE) def func1(): print(222) func() func1() ¶多个装饰器装饰同一个函数 def wrapper1(func): def inner(): print('wrapper1 ,before func') func() print('wrapper1 ,after func') return inner def wrapper2(func): def inner(): print('wrapper2 ,before func') func() print('wrapper2 ,after func') return inner @wrapper2 @wrapper1 def f(): print('in f') f()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-函数进阶]]></title>
    <url>%2Farchives%2Fd4e5ce76.html</url>
    <content type="text"><![CDATA[¶阅读目录 命名空间和作用域 函数嵌套及作用域链 函数名的本质 闭包 ¶一、命名空间和作用域 ¶命名空间 12345python代码运行的时候遇到函数是怎么做的?从python解释器开始执行之后，就在内存中开辟了一个空间每当遇到一个变量的时候，就把变量名和值之间的对应关系记录下来。但是当遇到函数定义的时候解释器只是象征性的将函数名读入内存，表示知道这个函数的存在了，至于函数内部的变量和逻辑解释器根本不关心。等执行到函数调用的时候，python解释器会再开辟一块内存来存储这个函数里的内容，这个时候，才关注函数里面有哪些变量，而函数中的变量会存储在新开辟出来的内存中。函数中的变量只能在函数的内部使用，并且会随着函数执行完毕，这块内存中的所有内容也会被清空。 我们给这个“存放名字与值的关系”的空间起了一个名字——叫做命名空间 代码在运行伊始，创建的存储“变量名与值的关系”的空间叫做全局命名空间 在函数的运行中开辟的临时的空间叫做局部命名空间 命名空间的本质：存放名字与值的绑定关系 在python之禅中提到过：命名空间是一种绝妙的理念，让我们尽情的使用发挥吧！ 命名空间一共分为三种： 全局命名空间 —— 我们写的代码但不是函数中的代码 # 是在程序从上到下被执行的过程中依次加载进内存的 # 放置了我们设置的所有变量名和函数名 局部命名空间 —— 函数 # 就是函数内部定义的名字 # 当调用函数的时候 才会产生这个名称空间 随着函数执行的结束 这个命名空间就又消失了 内置命名空间 —— python解释器 # 就是函数内部定义的名字 # 当调用函数的时候 才会产生这个名称空间 随着函数执行的结束 这个命名空间就又消失了 注：**内置命名空间**中存放了python解释器为我们提供的名字：input,print,str,list,tuple...它们都是我们熟悉的，拿过来就可以用的方法。 三种命名空间之间的加载与取值顺序： 加载顺序：内置命名空间(程序运行前加载)-&gt;全局命名空间(程序运行中：从上到下加载)-&gt;局部命名空间(程序运行中：调用时才加载) 取值顺序： 在局部调用：局部命名空间-----&gt;全局命名空间------&gt;内置命名空间 在全局调用：全局命名空间--------&gt;内置命名空间 在局部:可以使用全局、内置命名空间中的名字 在全局:可以使用内置命名空间中的名字，但是不能使用局部空间中的名字 在内置:不能使用局部和全局的名字的 综上所述，在找寻变量时，从小范围，一层一层到大范围去找寻 ¶作用域 作用域就是作用范围，按照生效范围可以分为全局作用域和局部作用域。 全局作用域：包含内置名称空间、全局名称空间，在整个文件的任意位置都能被引用、全局有效 局部作用域：局部名称空间，只能在局部范围内生效 globals和locals方法 全局作用域 —— 作用在全局 —— 内置和全局名字空间中的名字都属于全局作用域 ——globals() 局部作用域 —— 作用在局部 —— 函数（局部名字空间中的名字属于局部作用域） ——locals() 123456def func(): a = 12 b = 20 print(locals()) print(globals())func() globals 永远打印全局的名字 locals 输出什么 根据locals所在的位置 global关键字 1、声明一个全局变量。 2、在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字)。 1234567a = 10def func(): global a a = 20print(a)func()print(a) ps：对可变数据类型（list，dict，set）可以直接引用不用通过global 123456l1 = [1,2,3]def func(): l1.append(444)func()print(l1) #[1, 2, 3, 444] nonlocal关键字 1、nonlocal 只能用于局部变量 找上层中离当前函数最近一层的局部变量，不能修改全局变量。 2、声明了nonlocal的内部函数的变量修改会影响到 离当前函数最近一层的局部变量 3、对局部 也只是对 最近的 一层 有影响 12345678910111213def func(): name = 'wusir' def inner(): nonlocal name name = 'taibai' print(name) print(name) inner() print(name)func()wusirtaibaitaibai 123456789101112131415161718def add_b(): b = 42 def do_global(): b = 10 print(b) def dd_nonlocal(): nonlocal b b = b + 20 print(b) dd_nonlocal() print(b) do_global() print(b)add_b()310303042 ¶二、函数嵌套及作用域链 函数的嵌套调用 123456789def max2(x,y): m = x if x&gt;y else y return mdef max4(a,b,c,d): res1 = max2(a,b) res2 = max2(res1,c) res3 = max2(res2,d) return res3 # max4(23,-7,31,11) 函数的嵌套定义 定义在内部的函数无法直接在全局被调用 123456def f1(): print(&quot;in f1&quot;) def f2(): print(&quot;in f2&quot;) f2()f1() 123456789def f1(): def f2(): def f3(): print("in f3") print("in f2") f3() print("in f1") f2() f1() 函数的作用域链 123456def f1(): a = 1 def f2(): print(a) f2()f1() 12345678def f1(): a = 1 def f2(): def f3(): print(a) f3() f2()f1() 1234567def f1(): a = 1 def f2(): a = 2 f2() print('a in f1 : ',a)f1() ¶三、函数名的本质 函数名本质上就是一个变量，保存了函数所在的内存地址 1.可以被引用 1234def func(): print('in func')f = funcprint(f) 2.可以被当作容器类型的元素 1234567891011def f1(): print('f1')def f2(): print('f2')def f3(): print('f3')l = [f1,f2,f3]d = &#123;'f1':f1,'f2':f2,'f3':f3&#125; #调用l[0]()d['f2']() 3.可以当作函数的参数和返回值 不明白？那就记住一句话，就当普通变量用 第一类对象（first-class object）指 1.可在运行期创建 2.可用作函数参数或返回值 3.可存入变量的实体。 ¶四、闭包 1234def func(): name = 'eva' def inner(): print(name) 闭包函数： 内部函数包含对外部作用域而非全剧作用域名字的引用，该内部函数称为闭包函数 函数内部定义的函数称为内部函数 如何实现对内层函数的调用？ 1234567def func(): name = 'eva' def inner(): print(name) return innerf = func()f() 判断闭包函数的方法__closure__ #输出的__closure__有cell元素 ：是闭包函数 def func(): name = 'eva' def inner(): print(name) print(inner.__closure__) return inner f = func() f() #输出的__closure__为None ：不是闭包函数 name = 'egon' def func2(): def inner(): print(name) print(inner.__closure__) return inner f2 = func2() f2() 闭包的嵌套 1234567891011def wrapper(): money = 1000 def func(): name = 'eva' def inner(): print(name,money) return inner return funcf = wrapper()i = f()i() 闭包的好处：保护内存，闭包函数在内存中的局部命名空间不会随着函数的结束而结束]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-初识函数]]></title>
    <url>%2Farchives%2Fe03bb111.html</url>
    <content type="text"><![CDATA[¶阅读目录 为什么要用函数 函数的定义与调用 函数的返回值 函数的参数 总结 ¶为什么要用函数 打个比方，加入现在len()方法突然不能直接用了。。。 然后现在有一个需求，让你计算’hello world’的长度，你怎么计算？ 12345s1 = "hello world"length = 0for i in s1: length = length+1print(length) 好了，功能实现了，非常完美。然后现在又有了一个需求， 要计算另外一个字符串的长度，“hello eva” 于是，这个时候你的代码就变成了这样： 12345s2 = "hello eva"length = 0for i in s2: length = length+1print(length) 这样确实可以实现len方法的效果，但是总感觉不是那么完美？为什么呢？ 首先，之前只要我们执行len方法就可以直接拿到一个字符串的长度了，现在为了实现相同的功能我们把相同的代码写了好多遍 —— 代码冗余 其次，之前我们只写两句话读起来也很简单，一看就知道这两句代码是在计算长度，但是刚刚的代码却不那么容易读懂 —— 可读性差 12print(len(s1))print(len(s2)) ¶初识函数定义与调用 12345678910 #函数定义def mylen(): """计算s1的长度""" s1 = "hello world" length = 0 for i in s1: length = length+1 print(length) #函数调用 mylen() 总结一： 定义：def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个&quot;:&quot;。 def 是固定的，不能变，必须是连续的def三个字母，不能分开。。。它们要相亲相爱的在一起。 空格 为了将def关键字和函数名分开，必须空(四声)，当然你可以空2格、3格或者你想空多少都行，但正常人还是空1格。 函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并能表达函数功能 括号：是必须加的，先别问为啥要有括号，总之加上括号就对了！ 注释：每一个函数都应该对功能和参数进行相应的说明，应该写在函数下面第一行。以增强代码的可读性。 调用：就是 函数名() 要记得加上括号。 ¶函数的返回值 刚刚我们就写了一个函数，这个函数可以帮助我们计算字符串的长度，并且把结果打印出来。 但是，这和我们的len()方法还不是太一样。哪里不一样呢？ 以前我们调用len方法会得到一个值，我们必须用一个变量来接收这个值。 str_len = len('hello,world') 这个str_len就是‘hello，world’的长度。那我们自己写的函数能做到这一点么？我们也来试一下。 1234567891011 #函数定义def mylen(): """计算s1的长度""" s1 = "hello world" length = 0 for i in s1: length = length+1 print(length) #函数调用str_len = mylen()print('str_len : %s'%str_len) 很遗憾，如果你执行这段代码，得到的str_len 值为None，这说明我们这段代码什么也没有给你返回。 那如何让它也想len函数一样返回值呢？ 1234567891011 #函数定义def mylen(): """计算s1的长度""" s1 = "hello world" length = 0 for i in s1: length = length+1 return length #函数调用str_len = mylen()print('str_len : %s'%str_len 我们只需要在函数的最后加上一个return，return后面写上你要返回的值就可以了。 接下来就来研究一下这个return的用法: return关键字的作用 return 是一个关键字，翻译过来就是“返回”，所以我们管写在return后面的值叫“返回值” 要研究返回值，我们还要知道返回值有几种情况：分别是没有返回值、返回一个值、返回多个值 ¶没有返回值 不写return的情况下，会默认返回一个None 我们写的第一个函数，就没有写return，这就是没有返回值的一种情况。 123456789101112 #函数定义def mylen(): """计算s1的长度""" s1 = "hello world" length = 0 for i in s1: length = length+1 print(length) #函数调用str_len = mylen() #因为没有返回值，此时的str_len为Noneprint('str_len : %s'%str_len) 只写return，后面不写其他内容，也会返回None 这里要说一下return的其他用法，就是一旦遇到return，结束整个函数。 123456def ret_demo(): print(111) return print(222)ret = ret_demo()print(ret) return None：和上面的两种情况一样，我们一般不这样写 123456def ret_demo(): print(111) return None print(222)ret = ret_demo()print(ret) ¶返回一个值 刚刚我们已经写过一个返回一个值的情况 只需在return后面写上要返回的内容即可 ¶返回多个值 可以返回任意多个、任意数据类型的值 12345678910def ret_demo1(): '''返回多个值''' return 1,2,3,4def ret_demo2(): '''返回多个任意类型的值''' return 1,['a','b'],3,4ret1 = ret_demo1()print(ret1)ret2 = ret_demo2()print(ret2) 返回的多个值会被组织成元组被返回，也可以用多个值来接收 1234567891011def ret_demo2(): return 1,['a','b'],3,4 #返回多个值，用一个变量接收ret2 = ret_demo2()print(ret2) #返回多个值，用多个变量接收a,b,c,d = ret_demo2()print(a,b,c,d) #用多个值接收返回值：返回几个值，就用几个变量接收a,b,c,d = ret_demo2()print(a,b,c,d) 原因： &gt;&gt;&gt; 1,2 #python中把用逗号分割的多个值就认为是一个元组。 (1, 2) &gt;&gt;&gt; 1,2,3,4 (1, 2, 3, 4) &gt;&gt;&gt; (1,2,3,4) (1, 2, 3, 4) #序列解压一 &gt;&gt;&gt; a,b,c,d = (1,2,3,4) &gt;&gt;&gt; a 1 &gt;&gt;&gt; b 2 &gt;&gt;&gt; c 3 &gt;&gt;&gt; d 4 #序列解压二 &gt;&gt;&gt; a,_,_,d=(1,2,3,4) &gt;&gt;&gt; a 1 &gt;&gt;&gt; d 4 &gt;&gt;&gt; a,*_=(1,2,3,4) &gt;&gt;&gt; *_,d=(1,2,3,4) &gt;&gt;&gt; a 1 &gt;&gt;&gt; d 4 #也适用于字符串、列表、字典、集合 &gt;&gt;&gt; a,b = {'name':'eva','age':18} &gt;&gt;&gt; a 'name' &gt;&gt;&gt; b 'age' ¶函数的参数 1现在，我们已经把函数返回值相关的事情研究清楚了，我们自己已经完成了一个可以返回字符串长度的函数。但是现在这个函数还是不完美，之前我们使用len函数的时候得是length = len(&quot;hello world&quot;)，这样我可以想计算谁就计算谁的长度。但是现在我们写的这个函数，只能计算一个“hello world”的长度，换一个字符串好像就是不行了。这可怎么办？ 12345678910 #函数定义def mylen(s1): """计算s1的长度""" length = 0 for i in s1: length = length+1 return length #函数调用str_len = mylen("hello world")print('str_len : %s'%str_len) 我们告诉mylen函数要计算的字符串是谁，这个过程就叫做 传递参数，简称传参 我们调用函数时传递的这个“hello world”和定义函数时的s1就是参数 ¶实参与形参 参数还有分别： 我们调用函数时传递的这个“hello world”被称为实际参数，因为这个是实际的要交给函数的内容，简称实参。 定义函数时的s1，只是一个变量的名字，被称为形式参数，因为在定义函数的时候它只是一个形式，表示这里有一个&gt;参数，简称形参。 ¶传递多个参数 参数可以传递多个，多个参数之间用逗号分割 123456def mymax(x,y): the_max = x if x &gt; y else y return the_maxma = mymax(10,20)print(ma) 也正是因为需要传递多个参数、可以传递多个参数，才会有了后面这一系列参数相关的内容。。。 ¶位置参数 ¶站在实参角度 1. 按照位置传值 123456def mymax(x,y): #此时x=10,y=20 the_max = x if x &gt; y else y return the_maxma = mymax(10,20)print(ma) 2. 按照关键字传值 1234567def mymax(x,y): #此时x = 20,y = 10 print(x,y) the_max = x if x &gt; y else y return the_maxma = mymax(y = 10,x = 20)print(ma) 3. 位置、关键字形式混着用 1234567def mymax(x,y): #此时x = 10,y = 20 print(x,y) the_max = x if x &gt; y else y return the_maxma = mymax(10,y = 20)print(ma) 正确用法 问题一:位置参数必须在关键字参数的前面 问题二:对于一个形参只能赋值一次 ¶站在形参角度 位置参数必须传值 12345678910def mymax(x,y): #此时x = 10,y = 20 print(x,y) the_max = x if x &gt; y else y return the_max #调用mymax不传递参数ma = mymax()print(ma) #结果TypeError: mymax() missing 2 required positional arguments: 'x' and 'y' ¶默认参数 1. 使用 为什么要有默认参数：将变化比较小的值设置成默认参数 2. 默认参数的定义 1234567def stu_info(name,sex = &quot;male&quot;): &quot;&quot;&quot;打印学生信息函数，由于班中大部分学生都是男生， 所以设置默认参数sex的默认值为&apos;male&apos; &quot;&quot;&quot; print(name,sex)stu_info(&apos;alex&apos;)stu_info(&apos;eva&apos;,&apos;female&apos;) 3. 参数陷阱：默认参数是一个可变数据类型 12345678 # 如果默认参数的值是一个可变数据类型， # 那么每一次调用函数的时候， # 如果不传值就公用这个数据类型的资源def defult_param(a,l = []): l.append(a) print(l)defult_param(&apos;alex&apos;)defult_param(&apos;egon&apos;) ¶动态参数 按位置传值多余的参数都由args统一接收，保存成一个元组的形式 1234567def mysum(*args): the_sum = 0 for i in args: the_sum+=i return the_sumthe_sum = mysum(1,2,3,4)print(the_sum) **kwargs： 接受的是按照关键字传参的值，组织成一个字典 1234def stu_info(**kwargs): print(kwargs) print(kwargs[&apos;name&apos;],kwargs[&apos;sex&apos;])stu_info(name = &apos;alex&apos;,sex = &apos;male&apos;) 顺序：必须先定义位置参数，*args，再定义默认参数,**kwargs ¶总结 ¶定义函数的规则： 1.定义：def 关键词开头，空格之后接函数名称和圆括号()。 2.参数：圆括号用来接收参数。若传入多个参数，参数之间用逗号分割。 参数可以定义多个，也可以不定义。 参数有很多种，如果涉及到多种参数的定义，应始终遵循位置参数、*args、默认参数、**kwargs顺序定义。 如上述定义过程中某参数类型缺省，其他参数依旧遵循上述排序 3.注释：函数的第一行语句应该添加注释。 4.函数体：函数内容以冒号起始，并且缩进。 5.返回值：return [表达式] 结束函数。不带表达式的return相当于返回 None def 函数名(参数1,参数2,*args,默认参数,**kwargs): &quot;&quot;&quot;注释：函数功能和参数说明&quot;&quot;&quot; 函数体 …… return 返回值 ¶调用函数的规则： 1.函数名() 函数名后面+圆括号就是函数的调用。 2.参数： 圆括号用来接收参数。 若传入多个参数： 应按先位置传值，再按关键字传值 具体的传入顺序应按照函数定义的参数情况而定 3.返回值 如果函数有返回值，还应该定义“变量”接收返回值 如果返回值有多个，也可以用多个变量来接收，变量数应和返回值数目一致 无返回值的情况： 函数名() 有返回值的情况： 变量 = 函数名() 多个变量接收多返回值： 变量1，变量2，... = 函数名() ¶参数总结：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3之文件操作]]></title>
    <url>%2Farchives%2F74c6600f.html</url>
    <content type="text"><![CDATA[¶一、文件操作基本流程 计算机系统分为：计算机硬件，操作系统，应用程序三部分。 我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。 有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程： 123456 #1. 打开文件，得到文件句柄并赋值给一个变量f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r #2. 通过句柄对文件进行操作data=f.read() #3. 关闭文件f.close() 关闭文件的注意事项： 1234567891011打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：1、f.close() #回收操作系统级打开的文件2、del f #回收应用程序级的变量其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()虽然我这么说，但是很多同学还是会很不要脸地忘记f.close(),对于这些不长脑子的同学，我们推荐傻瓜式操作方式：使用with关键字来帮我们管理上下文with open(&apos;a.txt&apos;,&apos;w&apos;) as f: pass with open(&apos;a.txt&apos;,&apos;r&apos;) as read_f,open(&apos;b.txt&apos;,&apos;w&apos;) as write_f: data=read_f.read() write_f.write(data) ¶二、文件编码 f=open(…)是由操作系统打开文件，那么如果我们没有为open指定编码，那么打开文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。 12 #这就用到了上节课讲的字符编码的知识：若要保证不乱码，文件以什么方式存的，就要以什么方式打开。f=open('a.txt','r',encoding='utf-8') ¶三、文件的打开模式 1234567891011121314151617 #1. 打开文件的模式有(默认为文本模式)：r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】w，只写模式【不可读；不存在则创建；存在则清空内容】a， 只追加写模式【不可读；不存在则创建；存在则只追加内容】 #2. 对于非文本文件，我们只能使用b模式，"b"表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）rb wbab注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码 #3,‘+’模式（就是增加了一个功能）r+， 读写【可读，可写】w+，写读【可写，可读】a+， 写读【可写，可读】 #4，以bytes类型操作的读写，写读，写读模式r+b， 读写【可读，可写】w+b，写读【可写，可读】a+b， 写读【可写，可读】 ¶四、文件操作方法 ¶常用操作方法 1234567read（3）： 1. 文件打开方式为文本模式时，代表读取3个字符 2. 文件打开方式为b模式时，代表读取3个字节其余的文件内光标移动都是以字节为单位的如：seek，tell，truncate注意： 1. seek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的 2. truncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果。 1234567891011121314f.read() #读取所有内容,光标移动到文件末尾f.readline() #读取一行内容,光标移动到第二行首部f.readlines() #读取每一行内容,存放于列表中f.write('1111\n222\n') #针对文本模式的写,需要自己写换行符f.write('1111\n222\n'.encode('utf-8')) #针对b模式的写,需要自己写换行符f.writelines(['333\n','444\n']) #文件模式f.writelines([bytes('333\n',encoding='utf-8'),'444\n'.encode('utf-8')]) #b模式 #seek 光标移动到第几个字节的位置f.seek(0,0) 移动到最开始f.seek(0,2) 移动到最末尾 #tell 告诉你光标的位置f.tell() #readable #文件是否可读f.readable() ¶五、文件的修改 文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果，具体的说有两种实现方式： 方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器） 1234567import os # 调用系统模块with open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: data=read_f.read() #全部读入内存,如果文件很大,会很卡 data=data.replace('alex','SB') #在内存中完成修改 write_f.write(data) #一次性写入新文件os.remove('a.txt') #删除原文件os.rename('.a.txt.swap','a.txt') #将新建的文件重命名为原文件 方式二：将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件 1234567import oswith open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: for line in read_f: line=line.replace('alex','SB') write_f.write(line)os.remove('a.txt')os.rename('.a.txt.swap','a.txt')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3之深浅copy]]></title>
    <url>%2Farchives%2F48f2972.html</url>
    <content type="text"><![CDATA[¶定义： 在Python中对象的赋值其实就是对象的引用。当创建一个对象，把它赋值给另一个变量的时候，python并没有拷贝这个对象，只是拷贝了这个对象的引用而已。 浅拷贝：拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已。也就是，把对象复制一遍，但是该对象中引用的其他对象我不复制 深拷贝：外围和内部元素都进行了拷贝对象本身，而不是引用。也就是，把对象复制一遍，并且该对象中引用的其他对象我也复制。 ¶几个术语的解释： 1，变量：是一个系统表的元素，拥有指向对象的连接空间 2，对象：被分配的一块内存，存储其所代表的值 3，引用：是自动形成的从变量到对象的指针 4，注意：类型（int类型，long类型(python3已去除long类型，只剩下int类型的数据)）属于对象，不是变量 5，不可变对象：一旦创建就不可修改的对象，包括字符串、元组、数字 6，可变对象：可以修改的对象，包括列表、字典。 ¶应用的范围： 1，切片可以应用于：列表、元组、字符串，但不能应用于字典。 2，深浅拷贝，既可应用序列（列表、元组、字符串），也可应用字典。 ¶深浅拷贝的作用： 1，减少内存的使用 2，以后在做数据的清洗、修改或者入库的时候，对原数据进行复制一份，以防数据修改之后，找不到原数据。 ¶对于不可变对象的深浅拷贝： 不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。 一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。 12345678910111213141516171819202122232425262728293031323334353637import copy # 使用拷贝需要导入copy模块a=(1,2,3)print("=====第一种=号浅拷贝=====")b=aprint(a)print(b)print(id(a))print(id(b))print("=====另一种copy浅拷贝===")b=copy.copy(a)print(a)print(b)print(id(a))print(id(b))print("=====深拷贝=====")b=copy.deepcopy(a)print(a)print(b)print(id(a))print(id(b))# 结果如下：=====浅拷贝=====(1, 2, 3)(1, 2, 3)28145223359522814522335952=====另一种浅拷贝===(1, 2, 3)(1, 2, 3)28145223359522814522335952=====深拷贝=====(1, 2, 3)(1, 2, 3)28145223359522814522335952 ¶对于可变对象深浅拷贝: =浅拷贝：值相等，地址相等 copy浅拷贝：值相等，地址不相等 deepcopy深拷贝：值相等，地址不相等 12345678910111213141516171819202122232425262728293031323334353637import copy # 使用拷贝需要导入copy模块a=[1,2,3]print("=====第一种=号浅拷贝=====")b=aprint(a)print(b)print(id(a))print(id(b))print("=====另一种copy浅拷贝===")b=copy.copy(a)print(a)print(b)print(id(a))print(id(b))print("=====深拷贝=====")b=copy.deepcopy(a)print(a)print(b)print(id(a))print(id(b))#结果如下：=====浅拷贝=====[1, 2, 3][1, 2, 3]20076963215442007696321544=====另一种copy浅拷贝===[1, 2, 3][1, 2, 3]20076963215442007695909960=====深拷贝=====[1, 2, 3][1, 2, 3]20076963215442007696319560 ¶总结： 1，深浅拷贝都是对源对象的复制，占用不同的内存空间。 2，不可变类型的对象，对于深浅拷贝毫无影响，最终的地址值和值都是相等的。 3，可变类型： =浅拷贝： 值相等，地址相等 copy浅拷贝：值相等，地址不相等 deepcopy深拷贝：值相等，地址不相等 ¶参考]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3小知识点]]></title>
    <url>%2Farchives%2Ff1a41560.html</url>
    <content type="text"><![CDATA[¶1、id 查询内存地址 1234name = 'alex'print(id(name))li = [1,2,3]print(id(li)) ¶2、is 判断的是内存地址 ¶== 是比较值，is 是内存地址是否相同 1234name1 = 'alex@'name2 = 'alex@'print(name1 == name2)---Tureprint(name1 is name2)-----Ture ¶3、小数据池 Python中 int 与 str 存在小数据池，其他类型没有 int 范围 -5 —256—指向一个内存地址 str 如果是全部由字母组成的字符串 都是指向一个内存地址. 如果是数字与str(单个字母)想乘,则20以内(包含20)的是同一个内存地址. 其他数据类型 则没有小数据池概念. ¶4、编码进阶 ¶4.1 编码回顾 unicode :万国码 A : 0000 0001 0000 0001 0000 0001 0000 0001 32位 中: 0000 0101 0000 0001 0000 0001 0000 0001 32位 升级:utf-8 :用最少8位表示一个字符 A : 0000 0001 8位 欧洲 : 0000 0001 0000 0001 16位 亚洲 中 : 0000 0101 0000 0001 0000 0001 24位 gbk :国标 a : 0000 0001 8位 中 : 0000 0101 0000 0001 16位 12不同编码之间是不能互相识别对方的二进制,会报错,或者产生乱码.在你的字符串(文件),存储,传输时,必须使用非unicode的二进制(01010101). py3: 字符串:编码方式(在内存中的运行方式):默认都是unicode. ¶4.2 byte 表现形式 byte 对于非中文: 表现形式: b’alex’ 内部编码: utf-8 gbk,gb2312…(非unicode) 你设定的. 对于中文: 表现形式: b’xe3\xf2\x36\xe3\xf2\x36’ 内部编码: utf-8 gbk,gb2312…(非unicode) 你设定的. str 对于非中文: 表现形式: ‘alex’ 内部编码: unicode 对于中文: 表现形式: ‘中国’ 内部编码: unicode str &gt;&gt;&gt; byte b = s.encode(‘utf-8’) 123456s = 'alex'b = s.encode('utf-8')b1 = s.encode('gbk')print(s,type(s))-----alex &lt;class 'str'&gt;print(b,type(b))-----b'alex' &lt;class 'bytes'&gt;print(b1,type(b1))--b'alex' &lt;class 'bytes'&gt; 123456s = '中国'b = s.encode('utf-8')b1 = s.encode('gbk')print(s,type(s))print(b,type(b))------b'\xe4\xb8\xad\xe5\x9b\xbd' &lt;class 'bytes'&gt;print(b1,type(b1))----b'\xd6\xd0\xb9\xfa' &lt;class 'bytes'&gt;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3基础·二]]></title>
    <url>%2Farchives%2Fb7729c81.html</url>
    <content type="text"><![CDATA[一、什么是数据类型？ 我们人类可以很容易的分清数字与字符的区别，但是计算机并不能呀，计算机虽然很强大，但从某种角度上看又很傻，除非你明确的告诉它， 1是数字，“汉”是文字，否则它是分不清1和‘汉’的区别的，因此，在每个编程语言里都会有一个叫数据类型的东东， 其实就是对常用的各种数据类型进行了明确的划分，你想让计算机进行数值运算，你就传数字给它，你想让他处理文字，就传字符串类型给他。 Python中常用的数据类型有多种，如下： 整数(int) ,字符串(str),布尔值(bool),列表(list),元组(tuple),字典(dict),集合(set) 二、基础数据类型 ¶2.1 数字int 数字主要是用于计算用的，使用方法并不是很多，就记住一种就可以： 1234#bit_length() 当十进制用二进制表示时，最少使用的位数v = 11data = v.bit_length()print(data) ¶2.2 布尔值bool 布尔值就两种：True，False。就是反应条件的正确与否 真 1 True 假 0 False ¶2.3 字符串str ¶2.3.1 字符串的索引与切片 索引即下标，就是字符串组成的元素从第一个开始，初始索引为0以此类推 12345a = 'ABCDEFGHIJK'print(a[0])print(a[3])print(a[5])print(a[7]) 切片就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚） 1234567a = 'ABCDEFGHIJK'print(a[0:3])print(a[2:5])print(a[0:]) #默认到最后print(a[0:-1]) # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素print(a[0:5:2]) #加步长print(a[5:0:-2]) #反向加步长 ¶2.3.2 字符串常用方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#captalize,swapcase,titleprint(name.capitalize()) #首字母大写print(name.swapcase()) #大小写翻转msg='egon say hi'print(msg.title()) #每个单词的首字母大写# 内同居中，总长度，空白处填充ret2 = a1.center(20,"*") print(ret2)#数字符串中的元素出现的个数。# ret3 = a1.count("a",0,4) # 可切片# print(ret3)a2 = "hqw\t"#\t前面的补全# 默认将一个tab键变成8个空格，如果tab前面的字符长度不足8个，则补全8个，如果tab键前面的字符长度超过8个不足16个则补全16个，以此类推每次补全8个。ret4 = a2.expandtabs()print(ret4)a4 = "dkfjdkfasf54"#startswith 判断是否以...开头#endswith 判断是否以...结尾# ret4 = a4.endswith('jdk',3,6) # 顾头不顾腚# print(ret4) # 返回的是布尔值# ret5 = a4.startswith("kfj",1,4)# print(ret5)#寻找字符串中的元素是否存在# ret6 = a4.find("fjdk",1,6)# print(ret6) # 返回的找到的元素的索引，如果找不到返回-1# ret61 = a4.index("fjdk",4,6)# print(ret61) # 返回的找到的元素的索引，找不到报错。#split 以什么分割，最终形成一个列表此列表不含有这个分割的元素。# ret9 = 'title,Tilte,atre,'.split('t')# print(ret9)# ret91 = 'title,Tilte,atre,'.rsplit('t',1)# print(ret91)#format的三种玩法 格式化输出res='&#123;&#125; &#123;&#125; &#123;&#125;'.format('egon',18,'male')res='&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon',18,'male')res='&#123;name&#125; &#123;age&#125; &#123;sex&#125;'.format(sex='male',name='egon',age=18)#stripname='*egon**'print(name.strip('*')) print(name.lstrip('*'))print(name.rstrip('*'))#replacename='alex say :i have one tesla,my name is alex'print(name.replace('alex','SB',1))#####is系列name='jinxin123'print(name.isalnum()) #字符串由字母或数字组成print(name.isalpha()) #字符串只由字母组成print(name.isdigit()) #字符串只由数字组成 ¶2.4 元祖tuple 元组被称为只读列表，即数据可以被查询，但不能被修改 所以，字符串的切片操作同样适用于元组。例：（1，2，3）（“a”,“b”,“c”） ¶2.5 列表list 列表是python中的基础数据类型之一，其他语言中也有类似于列表的数据类型，比如js中叫数组，他是以[]括起来， 每个元素以逗号隔开，而且他里面可以存放各种数据类型比如： li = [‘alex’,123,Ture,(1,2,3,’wusir’),[1,2,3,’小明’,],{‘name’:’alex’}] 列表相比于字符串，不仅可以储存不同的数据类型，而且可以储存大量数据，32位python的限制是 536870912 个元素,64位python的限制是 &gt;1152921504606846975 个元素。而且列表是有序的，有索引值，可切片，方便取值。 ¶2.5.1 增 12345678910111213141516li = [1,'a','b',2,3,'a']# li.insert(0,55) #按照索引去增加# print(li)## li.append('aaa') #增加到最后# li.append([1,2,3]) #增加到最后# print(li)## li.extend(['q,a,w']) #迭代的去增# li.extend(['q,a,w','aaa'])# li.extend('a')# li.extend('abc')# li.extend('a,b,c')# print(li)列表的增 ¶2.5.2 删 123456789101112# l1 = li.pop(1) #按照位置去删除，有返回值# print(l1)# del li[1:3] #按照位置去删除，也可切片删除没有返回值。# print(li)# li.remove('a') #按照元素去删除# print(li)# li.clear() #清空列表列表的删 ¶2.5.3 改 12345678# 改# li = [1,'a','b',2,3,'a']# li[1] = 'dfasdfas'# print(li)# li[1:3] = ['a','b']# print(li)列表的改 ¶2.5.4 查 切片去查，或者循环去查 ¶2.5.5 其他操作 count（数）（方法统计某个元素在列表中出现的次数） 121 a = ["q","w","q","r","t","y"]2 print(a.count("q")) index（方法用于从列表中找出某个值第一个匹配项的索引位置） 121 a = ["q","w","r","t","y"]2 print(a.index("r")) sort （方法用于在原位置对列表进行排序）。 reverse （方法将列表中的元素反向存放）。 123451 a = [2,1,3,4,5]2 a.sort()# 他没有返回值，所以只能打印a3 print(a)4 a.reverse()#他也没有返回值，所以只能打印a5 print(a) ¶2.6 字典dict 字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。python对key进行哈希函数运算，根据计算的结果决定value的存储&gt;地址，所以字典是无序存储的，且key必须是可哈希的。可哈希表示key必须是不可变类型，如：数字、字符串、元组。 字典(dictionary)是除列表意外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 ¶2.6.1 增 123456789# dic['li'] = ["a","b","c"]# print(dic)# setdefault 在字典中添加键值对，如果只有键那对应的值是none,但是如果原字典中存在设置的键值对，则他不会更改或者覆盖。# dic.setdefault('k','v')# print(dic) # &#123;'age': 18, 'name': 'jin', 'sex': 'male', 'k': 'v'&#125;# dic.setdefault('k','v1') # &#123;'age': 18, 'name': 'jin', 'sex': 'male', 'k': 'v'&#125;# print(dic)字典的增 ¶2.6.2 删 123456789101112# dic_pop = dic.pop("a",'无key默认返回值') # pop根据key删除键值对，并返回对应的值，如果没有key则返回默认返回值# print(dic_pop)# del dic["name"] # 没有返回值。# print(dic)# dic_pop1 = dic.popitem() # 随机删除字典中的某个键值对，将删除的键值对以元祖的形式返回# print(dic_pop1) # ('name','jin')# dic_clear = dic.clear() # 清空字典# print(dic,dic_clear) # &#123;&#125; None字典的删 ¶2.6.3 改 12345# 改# dic = &#123;"name":"jin","age":18,"sex":"male"&#125;# dic2 = &#123;"name":"alex","weight":75&#125;# dic2.update(dic) # 将dic所有的键值对覆盖添加（相同的覆盖，没有的添加）到dic2中# print(dic2) ¶2.6.4 查 12345# value1 = dic["name"] # 没有会报错# print(value1)## value2 = dic.get("djffdsafg","默认返回值") # 没有可以返回设定的返回值# print(value2) ¶2.6.5 其他操作 123456789# item = dic.items()# print(item,type(item)) # dict_items([('name', 'jin'), ('sex', 'male'), ('age', 18)]) &lt;class 'dict_items'&gt;# 这个类型就是dict_items类型，可迭代的# keys = dic.keys()# print(keys,type(keys)) # dict_keys(['sex', 'age', 'name']) &lt;class 'dict_keys'&gt;# values = dic.values()# print(values,type(values)) # dict_values(['male', 18, 'jin']) &lt;class 'dict_values'&gt; 同上 字典的循环 1234567# dic = &#123;"name":"jin","age":18,"sex":"male"&#125;# for key in dic:# print(key)# for item in dic.items():# print(item)# for key,value in dic.items():# print(key,value) ¶2.7 集合 集合是无序的，不重复的数据集合，它里面的元素是可哈希的(不可变类型)，但是集合本身是不可哈希（所以集合做不了字典的键）的。以下是集合最重要的两点： 去重，把一个列表变成集合，就自动去重了。 关系测试，测试两组数据之前的交集、差集、并集等关系。 ¶2.7.1 集合的创建 123set1 = set(&#123;1,2,'barry'&#125;)set2 = &#123;1,2,'barry'&#125;print(set1,set2) # &#123;1, 2, 'barry'&#125; &#123;1, 2, 'barry'&#125; ¶2.7.2 集合的增 1234567891011set1 = &#123;'alex','wusir','ritian','egon','barry'&#125;set1.add('景女神')print(set1)#update：迭代着增加set1.update('A')print(set1)set1.update('老师')print(set1)set1.update([1,2,3])print(set1) ¶2.7.3 集合的删 12345678910111213set1 = &#123;'alex','wusir','ritian','egon','barry'&#125;set1.remove('alex') # 删除一个元素print(set1)set1.pop() # 随机删除一个元素print(set1)set1.clear() # 清空集合print(set1)del set1 # 删除集合print(set1) ¶2.7.4 集合的其他操作 ¶交集。（&amp; 或者 intersection） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 &amp; set2) # &#123;4, 5&#125;print(set1.intersection(set2)) # &#123;4, 5&#125; ¶并集。（| 或者 union） 12345set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 | set2) # &#123;1, 2, 3, 4, 5, 6, 7,8&#125;print(set2.union(set1)) # &#123;1, 2, 3, 4, 5, 6, 7,8&#125; ¶差集。（- 或者 difference） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 - set2) # &#123;1, 2, 3&#125;print(set1.difference(set2)) # &#123;1, 2, 3&#125; ¶反交集。 （^ 或者 symmetric_difference） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 ^ set2) # &#123;1, 2, 3, 6, 7, 8&#125;print(set1.symmetric_difference(set2)) # &#123;1, 2, 3, 6, 7, 8&#125; ¶子集与超集 12345678910复制代码set1 = &#123;1,2,3&#125;set2 = &#123;1,2,3,4,5,6&#125;print(set1 &lt; set2)print(set1.issubset(set2)) # 这两个相同，都是说明set1是set2子集。print(set2 &gt; set1)print(set2.issuperset(set1)) # 这两个相同，都是说明set2是set1超集。复制代码 ¶2.7.5 frozenset不可变集合，让集合变成不可变类型 12s = frozenset('barry')print(s,type(s)) # frozenset(&#123;'a', 'y', 'b', 'r'&#125;) &lt;class 'frozenset'&gt; 三、基础数据类型的总结 按存储空间的占用分（从低到高） 1234567复制代码数字字符串集合：无序，即无序存索引相关信息元组：有序，需要存索引相关信息，不可变列表：有序，需要存索引相关信息，可变，需要处理数据的增删改字典：无序，需要存key与value映射的相关信息，可变，需要处理数据的增删改 按存值个数区分 标量／原子类型数字，字符串容器类型列表，元组，字典 按可变不可变区分 可变列表，字典不可变数字，字符串，元组，布尔值 按访问顺序区分 直接访问数字顺序访问（序列类型）字符串，列表，元组key值访问（映射类型）字典 四、其他（for，enumerate，range） for循环：用户按照顺序循环可迭代对象的内容 1234567891011msg = '我们一起来学习'for item in msg: print(item)li = ['alex','银角','女神','egon','太白']for i in li: print(i)dic = &#123;'name':'太白','age':18,'sex':'man'&#125;for k,v in dic.items(): print(k,v) enumerate：枚举，对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 1234567li = ['alex','银角','女神','egon','太白']for i in enumerate(li): print(i)for index,name in enumerate(li,1): print(index,name)for index, name in enumerate(li, 100): # 起始位置默认是0，可更改 print(index, name) range：指定范围，生成指定数字 12345678for i in range(1,10): print(i)for i in range(1,10,2): # 步长 print(i)for i in range(10,1,-2): # 反向步长 print(i)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3基础·一]]></title>
    <url>%2Farchives%2F8cf2b228.html</url>
    <content type="text"><![CDATA[一、python介绍 ¶1.python的出生与应用 python的创始人为吉多·范罗苏姆（Guido van Rossum）。 1989年的圣诞节期间，吉多·范罗苏姆（中文名字：龟叔） 为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。 2017年7月的TIOBE排行榜，Python已经占据第四的位置 Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。 由上图可见，Python整体呈上升趋势，反映出Python应用越来越广泛并且也逐渐得到业内的认可！！！ Python可以应用于众多领域，如：数据分析、组件集成、网络服务、图像处理、数值计算和科学计算等众多领域。 目前业内几乎所有大中型互联网企业都在使用Python， 如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、 Google、Yahoo!、Facebook、NASA、百度、腾讯、汽车之家、美团等。 目前Python主要应用领域： 1.WEB开发——最火的Python web框架Django, 支持异步高并发的Tornado框架，短小精悍的flask,bottle, Django官方的标语把Django定义为the framework for perfectionist with deadlines(大意是一个为完全主义者开发的高效率web框架) 2.网络编程——支持高并发的Twisted网络框架， py3引入的asyncio使异步编程变的非常简单 3.爬虫——爬虫领域，Python几乎是霸主地位，Scrapy\Request\BeautifuSoap\urllib等，想爬啥就爬啥 4.云计算——目前最火最知名的云计算框架就是OpenStack,Python现在的火，很大一部分就是因为云计算 5.人工智能——谁会成为AI 和大数据时代的第一开发语言？这本已是一个不需要争论的问题。如果说三年前，Matlab、Scala、R、Java 和 Python还各有机会，局面尚且不清楚，那么三年之后，趋势已经非常明确了，特别是前两天 Facebook 开源了 PyTorch 之后，Python 作为 AI 时代头牌语言的位置基本确立，未来的悬念仅仅是谁能坐稳第二把交椅。 6.自动化运维——问问中国的每个运维人员，运维人员必须会的语言是什么？10个人相信会给你一个相同的答案，它的名字叫Python 7.金融分析——我个人之前在金融行业，10年的时候，我们公司写的好多分析程序、高频交易软件就是用的Python,到目前,Python是金融分析、量化交易领域里用的最多的语言 8.科学运算—— 你知道么,97年开始，NASA就在大量使用Python在进行各种复杂的科学运算，随着NumPy, SciPy, Matplotlib, Enthought librarys等众多程序库的开发，使的Python越来越适合于做科学计算、绘制高质量的2D和3D图像。和科学计算领域最流行的商业软件Matlab相比，Python是一门通用的程序设计语言，比Matlab所采用的脚本语言的应用范围更广泛 9.游戏开发——在网络游戏开发中Python也有很多应用。相比Lua or C++,Python 比 Lua 有更高阶的抽象能力，可以用更少的代码描述游戏业务逻辑，与 Lua 相比，Python 更适合作为一种 Host 语言，即程序的入口点是在 Python 那一端会比较好，然后用 C/C++ 在非常必要的时候写一些扩展。Python 非常适合编写 1 万行以上的项目，而且能够很好地把网游项目的规模控制在 10 万行代码以内。另外据我所知，知名的游戏&lt;文明&gt; 就是用Python写的 Python在一些公司的应用： 谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发 CIA: 美国中情局网站就是用Python开发的 NASA: 美国航天局(NASA)大量使用Python进行数据分析和运算 YouTube:世界上最大的视频网站YouTube就是用Python开发的 Dropbox:美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载 Instagram:美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发 Facebook:大量的基础库均通过Python实现的 Redhat: 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的 豆瓣: 公司几乎所有的业务均是通过Python开发的 知乎: 国内最大的问答社区，通过Python开发(国外Quora) 春雨医生：国内知名的在线医疗网站是用Python开发的 除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。 Python的发展史： 1989年，Guido开始写Python语言的编译器。 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数， 异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Granddaddy of Python web frameworks, Zope 1 was released in 1999 Python 1.0 - January 1994 增加了 lambda, map, filter and reduce Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础 Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生 Python 2.5 - September 19, 2006 Python 2.6 - October 1, 2008 Python 2.7 - July 3, 2010 In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible Python 3.0 - December 3, 2008 (这里要解释清楚 为什么08年就出3.0，2010年反而又推出了2.7？是因为3.0不向下兼容 2.0，导致大家都拒绝升级3.0，无奈官方只能推出2.7过渡版本) Python 3.1 - June 27, 2009 Python 3.2 - February 20, 2011 Python 3.3 - September 29, 2012 Python 3.4 - March 16, 2014 Python 3.5 - September 13, 2015 Python 3.6 - 2016-12-23 发布python3.6.0版 ¶2.python是什么编程语言 编程语言主要从以下几个角度为进行分类: 编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言， 每个分类代表什么意思呢，我们一起来看一下。 ¶2.1 编译型与解释型 编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快 而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的 这是因为计算机不能直接认识并执行我们写的语句,它只能认识机器语言(是二进制的形式) 编译型 优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。 缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。 解释型 优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。 缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。 ¶2.2 动态语言和静态语言 通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言 动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。 静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。 ¶2.3 强类型定义语言和弱类型定义语言 强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！ 例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。 通过上面这些介绍，我们可以得出，python是一门动态解释性的强类型定义语言。 ¶3.python的优缺点 先看优点: Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。 高级语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工 作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就几乎可以在市场上所有的系统平台上运行。 可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 可嵌入性————你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能 再看缺点: 速度慢，Python 的运行速度相比C语言确实慢很多，跟JAVA相比也要慢一些，因此这也是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来，比如你用C运一个程序花了0.01s,用Python是0.1s,这样C语言直接比Python快了10倍,算是非常夸张了，但是你是无法直接通过肉眼感知的，因为一个正常人所能感知的时间最小单位是0.15-0.4s左右，哈哈。其实在大多数情况下Python已经完全可以满足你对程序速度的要求，除非你要写对速度要求极高的搜索引擎等，这种情况下，当然还是建议你用C去实现的。 代码不能加密，因为PYTHON是解释性语言，它的源码都是以名文形式存放的，不过我不认为这算是一个缺点，如果你的项目要求源代码必须是加密的，那你一开始就不应该用Python来去实现。 线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。 当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。 ¶4.python的种类 CPython 当我们从Python官方网站下载并安装好Python 3.6后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。 IPython IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。 CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。 PyPy PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 Jython Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 小结： Python的解释器很多，但使用最广泛的还是CPython。 如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython， 而是通过网络调用来交互，确保各程序之间的独立性。 二、python基础初识 ps：python安装 打开官网https://www.python.org/Download 测试安装是否成功： windows --&gt; 运行 --&gt; 输入cmd ，然后回车，弹出cmd程序，输入python,如果能进入交互环境 ，代表安装成功。 ¶1.第一个python程序 ¶1.1文件执行 用notepad++创建一个文件，输入以下代码 print(&quot;Hello World!&quot;) 保存为HelloWorld.py , 注意要强调.py后缀名的作用 进入cmd命令行，执行python HelloWorld.py, 看结果 （注意要解释文件名前面加python 的原因是要把代码交给python解释器去解释执行） ¶1.2交互器执行 演示在python交互器下 ，输出hello world ！ 要强调python交互器是主要用来对代码进行调试用的 ¶2.注释 当行注释：# 被注释内容 多行注释：’’‘被注释内容’’’，或者&quot;&quot;“被注释内容”&quot;&quot; 代码注释原则: 不用全部加注释，只需要在自己觉得重要或不好理解的部分加注释即可 注释可以用中文或英文，但绝对不要拼音噢 ¶3.变量 变量是什么？ 变量：把程序运行的中间结果临时的存在内存里，以便后续的代码调用。 ¶3.1变量声明 #!/usr/bin/env python # -*- coding: utf-8 -*- name = &quot;taibai&quot; 上述代码声明了一个变量，变量名为： name，变量name的值为：“taibai” 变量的作用：昵称，其代指内存里某个地址中保存的内容 ¶3.2变量定义的规则： 变量名只能是 字母、数字或下划线的任意组合 变量名的第一个字符不能是数字 以下关键字不能声明为变量名 [‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’] 变量的定义要具有可描述性。 ¶3.3推荐定义方式： 1234567891011#驼峰体AgeOfOldboy = 56NumberOfStudents = 80#下划线age_of_oldboy = 56number_of_students = 80 ps:定义变量不好的方式举例 变量名为中文、拼音 变量名过长 变量名词不达意 你觉得哪种更清晰，我想你肯定会先第2种,第一种AgeOfOldboy咋一看以为是AngelaBaby ¶3.4变量的赋值： 12345#!/usr/bin/env python# -*- coding: utf-8 -*-name1 = "wupeiqi"name2 = "alex" ¶3.5常量： 常量即指不变的量，如pai 3.141592653…, 或在程序运行过程中不会改变的量 举例，假如老男孩老师的年龄会变，那这就是个变量，但在一些情况下，他的年龄不会变了，那就是常量。在Python中没有一个专门的语法代表常量，程序员约定俗成用变量名全部大写代表常量 AGE_OF_OLDBOY = 56 在c语言中有专门的常量定义语法，const int count = 60;一旦定义为常量，更改即会报错 ¶4.程序交互 12345# 将用户输入的内容赋值给 name 变量name = input("请输入用户名：") # 打印输入的内容print(name) 执行脚本就会发现，程序会等待你输入姓名后再往下继续走。 可以让用户输入多个信息，如下: 1234name = input("What is your name?")age = input("How old are you?")hometown = input("Where is your hometown?")print("Hello ",name , "your are ", age , "years old, you came from",hometown) 执行输出: 1234What is your name?Alex LiHow old are you?22Where is your hometown?ShanDongHello Alex Li your are 22 years old, you came from ShanDong ¶5.基础数据类型 什么是数据类型？ 我们人类可以很容易的分清数字与字符的区别，但是计算机并不能呀，计算机虽然很强大，但从某种角度上看又很傻，除非你明确的告诉它，1是数字，“汉”是文字，否则它是分不清1和‘汉’的区别的，因此，在每个编程语言里都会有一个叫数据类型的东东，其实就是对常用的各种数据类型进行了明确的划分，你想让计算机进行数值运算，你就传数字给它，你想让他处理文字，就传字符串类型给他。Python中常用的数据类型有多种，今天我们暂只讲3种， 数字、字符串、布尔类型 ¶5.1整数类型（int） int（整型） 在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807 long（长整型） 跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。 注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。 注意：在Python3里不再有long类型了，全都是int &gt;&gt;&gt; a= 2**64 &gt;&gt;&gt; type(a) #type()是查看数据类型的方法 &lt;type 'long'&gt; &gt;&gt;&gt; b = 2**60 &gt;&gt;&gt; type(b) &lt;type 'int'&gt; 除了int和long之外， 其实还有float浮点型, 复数型 ¶5.2字符串类型（str） &gt;&gt;&gt; name = &quot;Alex Li&quot; #双引号 &gt;&gt;&gt; age = &quot;22&quot; #只要加引号就是字符串 &gt;&gt;&gt; age2 = 22 #int &gt;&gt;&gt; &gt;&gt;&gt; msg = '''My name is taibai, I am 22 years old!''' #我擦，3个引号也可以 &gt;&gt;&gt; &gt;&gt;&gt; hometown = 'ShanDong' #单引号也可以 那单引号、双引号、多引号有什么区别呢？ 让我大声告诉你，单双引号木有任何区别，只有下面这种情况 你需要考虑单双的配合 msg = &quot;My name is Alex , I'm 22 years old!&quot; 多引号什么作用呢？作用就是多行字符串必须用多引号 1234567msg = &apos;&apos;&apos;今天我想写首小诗，歌颂我的同桌，你看他那乌黑的短发，好像一只炸毛鸡。&apos;&apos;&apos;print(msg) 字符串拼接 数字可以进行加减乘除等运算，字符串呢？让我大声告诉你，也能？what ?是的，但只能进行&quot;相加&quot;和&quot;相乘&quot;运算。 &gt;&gt;&gt; name ‘Eva_J' &gt;&gt;&gt; age ’18’ &gt;&gt;&gt; &gt;&gt;&gt; name + age #相加其实就是简单拼接 'Eva_J18’ &gt;&gt;&gt; &gt;&gt;&gt; name * 10 #相乘其实就是复制自己多少次，再拼接在一起 'Eva_JEva_JEva_JEva_JEva_JEva_JEva_JEva_JEva_JEva_J' 注意，字符串的拼接只能是双方都是字符串，不能跟数字或其它类型拼接 &gt;&gt;&gt; type(name),type(age2) (&lt;type 'str'&gt;, &lt;type 'int'&gt;) &gt;&gt;&gt; &gt;&gt;&gt; name 'Alex Li' &gt;&gt;&gt; age2 &gt;&gt;&gt; name + age2 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: cannot concatenate 'str' and 'int' objects #错误提示数字 和 字符 不能拼接 ¶5.3布尔值（True，False） 布尔类型很简单，就两个值 ，一个True(真)，一个False(假), 主要用记逻辑判断 但其实你们并不明白对么？ let me explain 我现在有2个值 ， a=3, b=5 , 我说a&gt;b你说成立么? 我们当然知道不成立，但问题是计算机怎么去描述这成不成立呢？ 或者说a&lt; b是成立，计算机怎么描述这是成立呢？ 没错，答案就是，用布尔类型 &gt;&gt;&gt; a=3 &gt;&gt;&gt; b=5 &gt;&gt;&gt; &gt;&gt;&gt; a &gt; b #不成立就是False,即假 False &gt;&gt;&gt; &gt;&gt;&gt; a &lt; b #成立就是True, 即真 True 计算机为什么要描述这种条件呢？因为接下来就可以根据条件结果来干不同的事情啦呀！比如 12345if a &gt; b print(a is bigger than b ) else print(a is smaller than b ) 上面是伪代码，但是不是意味着， 计算机就可以根据判断结果不同，来执行不同的动作啦？ 除了上面讲过的3种数据类型之外， 后面我们还会讲到如列表 、字典、集合等，越往后面学就越发现计算机好nb呀! ¶5.4格式化输出 现有一练习需求，问用户的姓名、年龄、工作、爱好 ，然后打印成以下格式 ------------ info of Eva_J ----------- Name : Eva_J Age : 18 job : Teacher ------------- end ----------------- 你怎么实现呢？你会发现，用字符拼接的方式还难实现这种格式的输出，所以一起来学一下新姿势 只需要把要打印的格式先准备好， 由于里面的 一些信息是需要用户输入的，你没办法预设知道， 因此可以先放置个占位符，再把字符串里的占位符与外部的变量做个映射关系就好啦 123456789101112131415name = input("Name:")age = input("Age:")job = input("Job:")hobbie = input("Hobbie:") info = '''------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 nameName : %s #代表 nameAge : %s #代表 agejob : %s #代表 jobHobbie: %s #代表 hobbie------------- end -----------------''' %(name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 print(info) %s就是代表字符串占位符，除此之外，还有%d,是数字占位符， 如果把上面的age后面的换成%d，就代表你必须只能输入数字啦 age: %d 我们运行一下，但是发现出错了。。。 说%d需要一个数字，而不是str, what? 我们明明输入的是数字呀，22，22呀。 不用担心 ，不要相信你的眼睛，我们调试一下，看看输入的到底是不是数字呢？ 怎么看呢？查看数据类型的方法是什么来着？type() name = input(&quot;Name:&quot;) age = input(&quot;Age:&quot;) print(type(age)) 执行输出是 Name:Alex Age:22 &lt;class 'str'&gt; #怎么会是str Job:IT .... 让我大声告诉你，input接收的所有输入默认都是字符串格式！ 要想程序不出错，那怎么办呢？简单，你可以把str转成int 12age = int( input("Age:") )print(type(age)) 肯定没问题了。相反，能不能把字符串转成数字呢？必然可以，str( yourStr ) 问题：现在有这么行代码 12msg = "我是%s,年龄%d,目前学习进度为80%"%('金鑫',18)print(msg) 这样会报错的，因为在格式化输出里，你出现%默认为就是占位符的% 但是我想在上面一条语句中最后的80%就是表示80%而不是占位符，怎么办？ 12msg = "我是%s,年龄%d,目前学习进度为80%%"%('金鑫',18)print(msg) 这样就可以了，第一个%是对第二个%的转译，告诉Python解释器这只是一个单纯的%，而不是占位符。 ¶5.5基本运算符 运算符 计算机可以进行的运算有很多种，可不只加减乘除这么简单，运算按种类可分为算数运算、比较运算、逻辑运算、赋值运算、成员运算、身份运算、位运算，今天我们暂只学习算数运算、比较运算、逻辑运算、赋值运算 算数运算 以下假设变量：a=10，b=20 比较运算 以下假设变量：a=10，b=20 赋值运算 以下假设变量：a=10，b=20 逻辑运算 针对逻辑运算的进一步研究： 例题：判断下列逻辑语句的True，False。 1234563 &gt; 4 or 4 &lt; 3 and 1 == 11 &lt; 2 and 3 &lt; 4 or 1 &gt; 2 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &lt; 11 &gt; 2 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 or 9 &lt; 81 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6not 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6 在没有()的情况下not 优先级高于 and，and优先级高于or，即优先级关系为( )>not>and>or，同一优先级从左往右计算。 x or y , x为真，值就是x，x为假，值是y；x and y, x为真，值是y,x为假，值是x。 成员运算： 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 Python运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： ¶5.6流程控制之if…else 假如把写程序比做走路，那我们到现在为止，一直走的都是直路，还没遇到过分叉口，想象现实中，你遇到了分叉口， 然后你决定往哪拐必然是有所动机的。你要判断那条岔路是你真正要走的路，如果我们想让程序也能处理这样的判断怎么办？ 很简单，只需要在程序里预设一些条件判断语句，满足哪个条件，就走哪条岔路。这个过程就叫流程控制。 if...else 语句 单分支 if 条件: 满足条件后要执行的代码 双分支 if 条件: 满足条件执行代码 else: if条件不满足就走这段 123456AgeOfOldboy = 48 if AgeOfOldboy &gt; 50 : print("Too old, time to retire..")else: print("还能折腾几年!") 缩进 这里必须要插入这个缩进的知识点 你会发现，上面的if代码里，每个条件的下一行都缩进了4个空格，这是为什么呢？ 这就是Python的一大特色，强制缩进，目的是为了让程序知道，每段代码依赖哪个条件， 如果不通过缩进来区分，程序怎么会知道，当你的条件成立后，去执行哪些代码呢？ 在其它的语言里，大多通过{}来确定代码块，比如C,C++,Java,Javascript都是这样， 看一个JavaScript代码的例子 1234567var age = 56if ( age &lt; 50)&#123; console.log("还能折腾") console.log('可以执行多行代码')&#125;else&#123; console.log('太老了')&#125; 在有{}来区分代码块的情况下，缩进的作用就只剩下让代码变的整洁了。 Python是门超级简洁的语言，发明者定是觉得用{}太丑了，所以索性直接不用它， 那怎么能区分代码块呢？答案就是强制缩进。 Python的缩进有以下几个原则: 顶级代码必须顶行写，即如果一行代码本身不依赖于任何条件，那它必须不能进行任何缩进 同一级别的代码，缩进必须一致 官方建议缩进用4个空格，当然你也可以用2个，如果你想被人笑话的话。 多分支 回到流程控制上来，if…else …可以有多个分支条件 12345678910if 条件: 满足条件执行代码elif 条件: 上面的条件不满足就走这个elif 条件: 上面的条件不满足就走这个elif 条件: 上面的条件不满足就走这个else: 上面所有的条件不满足就走这段 写个猜年龄的游戏吧 age_of_oldboy = 48 12345678910guess = int(input("&gt;&gt;:")) if guess &gt; age_of_oldboy : print("猜的太大了，往小里试试...") elif guess &lt; age_of_oldboy : print("猜的太小了，往大里试试...") else: print("恭喜你，猜对了...") 上面的例子，根据你输入的值不同，会最多得到3种不同的结果 再来个匹配成绩的小程序吧，成绩有ABCDE5个等级，与分数的对应关系如下 A 90-100 B 80-89 C 60-79 D 40-59 E 0-39 要求用户输入0-100的数字后，你能正确打印他的对应成绩 score = int(input(“输入分数:”)) 123456789101112if score &gt; 100: print("我擦，最高分才100...")elif score &gt;= 90: print("A")elif score &gt;= 80: print("B")elif score &gt;= 60: print("C")elif score &gt;= 40: print("D")else: print("太笨了...E") 这里有个问题，就是当我输入95的时候 ，它打印的结果是A,但是95 明明也大于第二个条件elif score &gt;=80:呀, 为什么不打印B呢？这是因为代&gt;码是从上到下依次判断，只要满足一个，就不会再往下走啦，这一点一定要清楚呀！ ¶5.7流程控制之–while循环 我们已经学会用if … else 来猜年龄的游戏啦，但是只能猜一次就中的机率太小了， 如果我想给玩家3次机会呢？ 就是程序启动后，玩家最多可以试3次，这个怎么弄呢？你总不会想着把代码复制3次吧。。。。 1234567891011121314151617181920212223242526272829303132333435age_of_oldboy = 48 guess = int(input("&gt;&gt;:")) if guess &gt; age_of_oldboy : print("猜的太大了，往小里试试...") elif guess &lt; age_of_oldboy : print("猜的太小了，往大里试试...") else: print("恭喜你，猜对了...") #第2次guess = int(input("&gt;&gt;:")) if guess &gt; age_of_oldboy : print("猜的太大了，往小里试试...") elif guess &lt; age_of_oldboy : print("猜的太小了，往大里试试...") else: print("恭喜你，猜对了...") #第3次guess = int(input("&gt;&gt;:")) if guess &gt; age_of_oldboy : print("猜的太大了，往小里试试...") elif guess &lt; age_of_oldboy : print("猜的太小了，往大里试试...") else: print("恭喜你，猜对了...") 即使是小白的你，也觉得的太low了是不是，以后要修改功能还得修改3次， 因此记住，写重复的代码是程序员最不耻的行为。 那么如何做到不用写重复代码又能让程序重复一段代码多次呢？ 循环语句就派上用场啦 语法 基本循环 123456while 条件: # 循环体# 如果条件为真，那么循环体则执行# 如果条件为假，那么循环体不执行 while 指 当其后面的条件 成立 ，就执行while下面的代码 写个让程序从0打印到100的程序 ，每循环一次，+1 count = 0 while count &lt;= 100 : #只要count&lt;=100就不断执行下面的代码 print(&quot;loop &quot;, count ) count +=1 #每执行一次，就把count+1，要不然就变成死循环啦，因为 count一直是0 输出 loop 0 loop 1 loop 2 loop 3 .... loop 98 loop 99 loop 100 如果我想实现打印1到100的偶数怎么办呢？ 那就得先搞清，怎么判断一个数字是偶数(能被2整除的就是偶数), 怎么判断能否被2整除？ 简单，除完2没有余数就是啦。这里要用到取模算运算符了 &gt;&gt;&gt; 10%2 &gt;&gt;&gt; 8%2 #无余数，是偶数 &gt;&gt;&gt; 7%2 #有余数，是奇数 放到我们的循环程序里 count = 0 while count &lt;= 100 : #只要count&lt;=100就不断执行下面的代码 if count % 2 == 0: #是偶数 print(&quot;loop &quot;, count) count +=1 #每执行一次，就把count+1，要不然就变成死循环啦，因为count一直是0 输出 loop 0 loop 2 loop 4 loop 6 .... loop 96 loop 98 loop 100 死循环 有一种循环叫死循环，一经触发，就运行个天荒地老、海枯石烂。 while 是只要后边条件成立(也就是条件结果为真)就一直执行，怎么让条件一直成立呢？ count = 0 while True: #True本身就是真呀 print(&quot;你是风儿我是沙,缠缠绵绵到天涯...&quot;,count) count +=1 循环中止语句 如果在循环的过程中，因为某些原因，你不想继续循环了，怎么把它中止掉呢？这就用到break 或 continue 语句 break用于完全结束一个循环，跳出循环体执行循环后面的语句 continue和break有点类似，区别在于continue只是终止本次循环，接着还执行后面的循环，break则完全终止循环 count = 0 while count &lt;= 100 : #只要count&lt;=100就不断执行下面的代码 print(&quot;loop &quot;, count) if count == 5: break count +=1 #每执行一次，就把count+1，要不然就变成死循环啦，因为count一直是0 print(&quot;-----out of while loop ------&quot;) 输出 loop 0 loop 1 loop 2 loop 3 loop 4 loop 5 -----out of while loop ------ break 12345678count = 0while count &lt;= 100 : count += 1 if count &gt; 5 and count &lt; 95: #只要count在6-94之间，就不走下面的 print语句，直接进入下一次loop continue print("loop ", count) print("-----out of while loop ------") 输出 loop 1 loop 2 loop 3 loop 4 loop 5 loop 95 loop 96 loop 97 loop 98 loop 99 loop 100 loop 101 -----out of while loop ------ continue while … else … 与其它语言else 一般只与if 搭配不同，在Python 中还有个while …else 语句 while 后面的else 作用是指，当while 循环正常执行完，中间没有被break 中止的话，就会执行else后面的语句 1234567count = 0while count &lt;= 5 : count += 1 print("Loop",count) else:print("循环正常执行完啦")print("-----out of while loop ------") 输出 Loop 1 Loop 2 Loop 3 Loop 4 Loop 5 Loop 6 循环正常执行完啦 -----out of while loop ------ 如果执行过程中被break啦，就不会执行else的语句啦 123456789count = 0while count &lt;= 5 : count += 1 if count == 3:break print("Loop",count) else:print("循环正常执行完啦")print("-----out of while loop ------") 输出 Loop 1 Loop 2 -----out of while loop ------ 三、开发工具 到现在为止，我们也是写过代码的人啦，但你有没有发现，每次写代码要新建文件、写完保存时还要选择存放地点，执行时还要切换到命令行调用&gt;python解释器，好麻烦呀，能否一气呵成，让我简单的写代码？此时开发工具IDE上场啦，一个好的IDE能帮你大大提升开发效率。 很多语言都有比较流行的开发工具，比如JAVA 的Eclipse, C#,C++的VisualStudio, Python的是啥呢？ Pycharm，最好的Python 开发IDE ¶安装 下载地址：https://www.jetbrains.com/pycharm/download 选择Professional 专业版 ¶破解 1.下载crack激活包，通过截获截止时间骗过pycharm; 下载地址：https://pan.baidu.com/s/1smpmI9R 将下载的文件放入PyCharm安装bin目录下: 2.在pycharm.exe.vmoptions ，pycharm64.exe.vmoptions两文件里加入 -javaagent:D:\Program Files\JetBrains\PyCharm 2017.3.3\bin\JetbrainsCrack-2.6.10-release-enc.jar 你自己目录位置 3.如果已有注册码无须填写，没用可以登录http://idea.lanyus.com/ 点击获得注册码————复制 4.启动pycharm————粘贴激活码 5.pycharm设置教程 6.pycharm代码配色方案 ok!大功告成，开启python之旅吧！]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages自定义域名开启HTTPS]]></title>
    <url>%2Farchives%2F92147245.html</url>
    <content type="text"><![CDATA[GitHub Pages由于其免费，轻量，搭建方便等缘故已经成为很多coder搭建博客的首选方案。 同时，GitHub Pages还支持自定义域名访问，这就让更多人有兴趣实用了。 但，一旦你开启了自定义域名，通过自定义域名访问，不再是HTTPS了。 这篇博客就是帮你实现自定义域名的HTTPS支持。 2018年05月18日 更新 据最新了解只要你域名CNAME到你的GitHub Page页面，github会自动给你申请一张你域名的Let’s Encrypt证书,而且你还可以在设置里开启强制HTTPS选项。 我们这里主要借助的是Cloudflare免费的CDN服务，让你的GitHub博客支持HTTPS。 我们可以先看一下最后成果。 ¶准备 在开始之前，你需要先注册一个Cloudflare账号。 ¶修改DNS服务器 在你注册完成，登录后，Cloudflare会提示你添加自己的站点，比如我的自定义域名是 qvchuang.top， 就填这个,如下图一样(如果没有，点击右上角 Add Site即可) 填写后，Cloudfire会去查询你的DNS记录 如果你的DNS解析服务没有设置成Cloudflare,Cloud会提示你改变你的DNS域名解析服务，如下所示 接下来你只需要，将你的DNS解析服务换成Cloudflare给你的两个地址即可 例如，我用的是阿里云，直接到阿里的域名管理，修改DNS即可 修改完DNS后，回到Cloudflare点击继续进入主界面。 主界面应该显示 Status: Website not active，这时需要等待DNS生效，一般1个小时左右就能生效了，如果超过一天还未生效建议查看是否正确修改DNS，生效后再进入Cloudflare主界面，点击 Recheck Nameservers 重新检查DNS服务器，如果已生效，Status就会显示 Active 并显示为绿色，这样就修改成功了 ¶添加DNS记录 CNAME： 将www.qvchuang.top ☞ qvchuang.top A : 将 qvchuang.top ☞ github pages 的IP 192.30.252.153 A : 将 qvchuang.top ☞ github pages 的IP 192.30.252.154 ¶开启SSL加密 点击Crypto按钮，并设置SSL为 Full 下滑找到Always Use HTTPS 并开启 ¶设置页面规则 同时，我们还需要设置一些页面规则，将所有该站点的资源全部走HTTPS 到这里，你就全部配置好了。等待一段时间，当你的状态变成如下所示时说明你以成功设置 ¶参考 https://blog.vinlic.com/p/50505/ https://razeen.me/post/https-githubpages.html]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加个Valine评论系统]]></title>
    <url>%2Farchives%2Fc568d0de.html</url>
    <content type="text"><![CDATA[现在我在 Hexo 的 yilia 主题上用上了 valine 评论系统。 前几天无意中看到了关于 valine 的评论，看了一下，感觉很不错 正好我对来必力不太满意。那就研究一下，看看能不能用上。 先附上之前来必力的教程 ¶简单记录一下的过程 主要参考 @Deserts 、@云淡风轻 ¶部署云引擎 先简单看了一下，这个评论系统的基础是 LeanCloud，先去注册一个账号，点这里过去 然后创建应用，应用名字什么的随意 创建应用之后就可以得到 Key 了，这个等一下会用到的 然后设置安全域名 部署云引擎，这一部分去看 @Deserts 博客里关于云引擎部署的部分吧，反正原理我不懂 云引擎环境变量我可以简单解释一下（新版增加了不少环境变量，怎么部署请看原站） ¶修改主题模板 这里基本上是照抄 https://github.com/litten/hexo-theme-yilia/pull/646 _config.yml 12345678910 #6、Valine https://valine.js.orgvaline: appid: #Leancloud应用的appId appkey: #Leancloud应用的appKey verify: false #验证码 notify: false #评论回复提醒 avatar: &apos;&apos; #评论列表头像样式：&apos;&apos;/mm/identicon/monsterid/wavatar/retro/hide avatar_cdn: &apos;https://sdn.geekzu.org/avatar/&apos; #头像CDN placeholder: &apos;瞎白话&apos; #评论框占位符 pageSize: 15 #评论分页 其中 verify 和 notify 一定要是 false，不要打开，不要手贱 avatar 参数详见 https://valine.js.org/configuration.html 在这里设置自定义头像 https://cn.gravatar.com/ themes\yilia\layout_partial\article.ejs 重写了一下 style，应该可以做到响应式布局了 12345678910111213&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt; &lt;section id=&quot;comments&quot; class=&quot;comments&quot;&gt; &lt;style&gt; .comments&#123;margin:30px;padding:10px;background:#fff&#125; @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:#fff&#125;&#125; &lt;/style&gt; &lt;%- partial(&apos;post/valine&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;/section&gt;&lt;% &#125; %&gt; themes\yilia\layout_partial\post\valine.ejs &lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src='//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'&gt;&lt;/script&gt; &lt;script&gt; var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false; var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false; new Valine({ av: AV, el: '#vcomment', notify: notify, verify: verify, app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;, app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;, placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;, avatar: &quot;&lt;%= theme.valine.avatar %&gt;&quot;, avatar_cdn: &quot;&lt;%= theme.valine.avatar_cdn %&gt;&quot;, pageSize: &lt;%= theme.valine.pageSize %&gt; }); if(window.location.hash){ var checkExist = setInterval(function() { if ($(window.location.hash).length) { $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000); clearInterval(checkExist); } }, 100); } &lt;/script&gt; 这里要注意一下 el 参数，我就是被这个坑爹的参数给坑了半个多小时，el 参数要和上面的id一致。 具体有哪些参数可以自己定义，可以看这里 https://valine.js.org/configuration ¶测试效果 完成了上面的工作，就可以试试能不能正常使用了 注意，在本地测试的时候是不能正常加载评论的，因为你设置了域名限制 ¶评论样式 ¶原文链接 叉叉白]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习笔记(三)]]></title>
    <url>%2Farchives%2Fd74dec0d.html</url>
    <content type="text"><![CDATA[此学习笔记根据慕课网课程“与MYSQL的零距离接触”学习总结 4.操作数据表中的记录（增删改查） ¶4-1 插入记录INSERT 第一种方法： 插入单条记录：INSERT [ INFO ] tbl_name [ ( col_name ) ] VALUES（…）； 插入多条记录：INSERT [ INFO ] tbl_name [ ( col_name ) ] VALUES（…）, （…）, （…）； 列名称col_name如果省略掉的话就要为所有的字段依次要赋值 如果为自动编号的字段赋值的话，我们可以采用NULL 或 DEFAULT 让其采用默认的递增的方式来实现 第二种方法： INSERT [INFO] tbl_name SET col_name=val，col_name=val； 说明：与第一种方式的区别在于，此方法可以使用子查询（SubQuery），但是一次只能插入一条记录 第三种方法：（将查找的记录插入到表中） INSERT tbl_name(col_name) SELECT col_name FROM tbl_name [ WHERT 条件 ]； ¶4-2 单表更新记录UPDATE UPDATE tbl_name SET col_name=(val)，col_name=(val)； UPDATE tbl_name SET col_name=(val) WHERR 条件； ¶4-3 单表删除记录DELETE DELETE FROM tbl_name [ WHERE 条件 ]; 如果省略WHERE则会删除数据表的所以数据 ¶4-4 MySQL查询表达式解析 SELECT col_name FROM 表名； SELECT col_name AS 别名 FROM 表名； 查询表达式： 每一个表达式表示想要的一列，必须有至少一个。 多个列之间以英文逗号分隔。 星号（）表示所有列，tbl_name. 可以表示命名表的所有列。 查询表达式可以使用 [AS] alias_name 为其赋予别名。 别名可用于 GROUP BY , ORDRE BY 或 HAVING 字句。 字段出现的顺序将影响结果集出现的顺序 字段的别名也将影响到以后的结果集 ¶4-5 WHERE语句进行条件查询 SELECT col_name FROM tbl_name [FROM 条件]; 条件表达式： 对记录进行过滤，如果没有指定WHERE字句，则显示所有记录。 在WHERE表达式中，可以使用MySQL支持的函数或运算符。 ¶4-6 GROUP BY 语句对查询结果分组 SELECT col_name FROM tbl_name GROUP BY col_name; ¶4-7 ORDER BY语句对查询结果排序 SELECT col_name FROM tbl_name ORDER BY col_name [ ASC | DESC ]; ASC 升序（默认的） DESC 降序 ¶4-8 LIMIT语句限制查询数量 SELECT col_name FROM tbl_name LIMIT val; ¶总结 记录操作语句增INSERT删DELETE改UPDATE查SELECT 未完待续。。。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习笔记(二)]]></title>
    <url>%2Farchives%2Fa9becc26.html</url>
    <content type="text"><![CDATA[此学习笔记根据慕课网课程“与MYSQL的零距离接触”学习总结 3.约束以及修改数据表 ¶3-1 外键约束的要求解析 外键约束：保证数据一致性、完整性，实现一对一或一对多关系。 FOREIGN KEY (外键列名称) REFERENCES 父表(参照列名称)； 外键约束的要求： 父表和子表必须使用相同的存储引擎，而且禁止使用临时表 数据表的存储引擎只能为InnoDB。 外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。 显示索引：SHOW INDEXES FROM 表名； 或者：SHOW INDEXES FROM 表名\G；（以网格的形式来呈现） 删除索引：ALEER TABLE tbl_name DROP INDEX 索引名称; ¶3-2 外键约束的参照操作 1.CASCADE 从父表删除或更新且自动删除或更新子表中匹配的行 2.SET NULL 从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子列表没有指定NOT NULL 3.RESTRICT 拒绝对父表的删除或更新操作 4.NO ACTION 标准SQL的关键字，在MySQL中与RESTRICT相同。 语法结构：FOREIGN KEY (外键列名称) REFERENCES 父表(参照列名称) ON DELETE CASCADE； mysql&gt; CREATE TABLE users1( -&gt; id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, -&gt; username VARCHAR(10) NOT NULL, -&gt; pid SMALLINT UNSIGNED, -&gt; FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE -&gt; ); Query OK, 0 rows affected (0.53 sec) ¶3-3 表级约束与列级约束 对一个数据列建立的约束，称为列级约束。 对多个数据列建立的约束，称为表级约束。 列级约束既可以在列定义时声明，也可以在定义后声明。 表级约束只能在列定义后声明。 ¶3-4 添加/删除列 添加单列： ALTER TABLE tbl_name ADD col_name column_definition FIRST | AFTER col_name; ALTER TABLE 表名称 ADD 列名称 列定义 FIRST | AFTER 列名称; FIRST将新添加的这一列置于所有列最前面 AFTER col_name 将新添加的列置于你指定列的后方 如果省略FIRST | AFTER col_name，则置于所有列之后 添加多列： ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition, …… ); 添加多列时不能指定位置关系，只能在原来数据列的下方。 删除单列： ALTER TABLE tbl_name DROP col_name; 删除多列： ALTER TABLE tbl_name DROP col_name1,DROP col_name2; ¶3-5 添加/删除约束 (注：col_name:列名称) 添加/删除主键约束： ALTER TABLE tbl_name ADD PRIMARY KEY (col_name); ALTER TABLE tbl_name DROP PRIMARY KEY; 添加/删除唯一约束： ALTER TABLE tbl_name ADD UNIQUE (col_name); ALEER TABLE tbl_name DROP INDEX 索引名称; (也可以用于删除其他索引) 添加/删除外键约束： ALTER TABLE tbl_name ADD FOREIGN KEY (外键列名称) REFERENCES 父表(参照列名称); ALTER TABLE tbl_name DROP FOREIGN KEY 约束名称； （外键约束名称通过SHOW CREATE TABLE tbl_name 查看） 例如：| users2 | CREATE TABLE `users2` ( `username` varchar(10) NOT NULL, `pid` smallint(5) unsigned DEFAULT NULL, `id` smallint(5) unsigned NOT NULL, `age` tinyint(3) unsigned NOT NULL, KEY `pid` (`pid`), CONSTRAINT `users2_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 | mysql&gt; ALTER TABLE users2 DROP FOREIGN KEY users2_ibfk_1; 添加/删除默认约束： ALTER TABLE tbl_name ALTER col_name SET DEFAULT 默认值; ALTER TABLE tbl_name ALTER col_name DROP DEFAULT; ¶3-6 修改列定义和更名数据表 修改列定义： ALTER TABLE tbl_name MODIFY col_name column_definition FIEST | AFTER col_name; ALTER TABLE 表名称 MODIFY列名称 列定义 FIRST | AFTER 列名称; 修改列名称：（除了修改列定义还可以修改列名称） ALTER TABLE tbl_name CHANGE old_col_name new_col_name column_definition FIRST | AFTER col_name; ALTER TABLE tbl_name CHANGE 旧的列名称 新的类名称 列定义 FIRST | AFTER col_name; 数据表更名： 方法1： ALTER TABLE tbl_name RENAME new_tbl_name; 方法2： RENAME TABLE tbl_name TO new_tbl_name; ¶总结 约束： 按功能划为NOT NULL（非空约束）PRIMARY KEY（主键约束）UNIQUE KEY（唯一约束）DEFAULT（默认约束）FOREIGN KEY（外键约束） 按数据列的数目划为表级约束列级约束 修改数据表： 针对字段的操作：添加/删除字段、修改列定义、修改列名称等 针对约束的操作：添加/删除各种约束 针对数据表的操作：数据表更名（两种方式） 未完待续。。。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心烦的时候，就这样安慰自己]]></title>
    <url>%2Farchives%2F4643a402.html</url>
    <content type="text"><![CDATA[生活，有时感觉莫名的心烦 心烦的时候，最好的是沉默 不必喝酒，出去走走 那小路和树林 那天空和海滩 就在身旁 不必多怨，言多不逊 不必伤怀，曲折有度 许过了就算了，算了就消失了 心烦，是自己的，不是别人的 生活，有时真的让人无语，让人心碎 有些路，不想走也得走 跪着也得撑下去 有些事，不想做也得做 流着泪也要做好 有些情，舍不得也得放下 哪怕心再痛再苦 生活，总是在最苦最难时绽放美丽 当一扇窗关闭的时候 另一扇窗已经悄然打开 酷寒，往往意味着春天 孤独，往往意味着精彩 沉默，往往意味着思索 人活着，不仅是生存 而且要证明自己 活着，就要学会放弃 学会珍惜和成长 活着，就要努力去证明自己 去不懈的追求 去默默的付出 --END--]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习笔记(一)]]></title>
    <url>%2Farchives%2F68f5744.html</url>
    <content type="text"><![CDATA[此学习笔记根据慕课网课程“与MYSQL的零距离接触”学习总结 首先安装好mysql，安装方式可以选择MSI引导安装程序或者压缩包安装方式，具体安装步骤请自行百度。 1.初涉mysql ¶1-1 启动与停止mysql服务 启动MySQL服务命令：net start mysql 作用：启动MySQL服务，注意此时的“mysql”表示服务名 如果想停止MySQL服务，可以使用命令：net stop mysql 只有停止了MySQL服务之后，才能再去删除MySQL服务。 ¶1-2 mysql登录与退出 登录mysql mysql -uroot -p 【mysql -u(用户名） -p（密码）】 在mysql控制台下以root用户登录，默认root用户是没有密码的，直接按回车。 修改用户密码 mysql&gt; alter user 'root'@'localhost' identified by 'youpassword'; 或者 mysqlset password=password(&quot;youpassword&quot;); mysql退出三种方法： mysql &gt; exit; mysql &gt; quit; mysql &gt; \q; ¶1-3 修改mysql提示符 mysql&gt;prompt \d (输入想要设置的提示符或者命令) \D 完整的日期 \d 当前数据库 \h 服务器名称 \u 当前用户 ¶1-4 mysql常用命令及语法规范 mysql语句的规范： 1.关键字与函数名称全部大写 2.数据库名称、表名称、字段名称全部小写 3.SQL语句必须以分号结尾 创建数据库的语法结构：{}代表必选项一定要有的、丨代表或、[]代表可选项 CREATE { DATABASE 丨 SCHEMA } [ IF NOT EXISTS ] db_name [ DEFAULT ] CHARACTER SET [ = ] CHARACTER SET [ = ] 编码格式; (创建数据库时所使用的编码方式） 修改数据库的编码格式： ALTER { DATABASE 丨 SCHEMA } [db_name] [DEFAULT] CHARACTER SET [=] 编码格式； 删除数据库DROP { DATABASE 丨 SCHEMA } [ IF EXISTS ] db_name;查看所有数据库SHOW { DATABASES 丨 SCHEMAS };查看创建数据库信息SHOW CREATE DATABASE db_name;查看错误信息SHOW WARNINGS;进入数据库USE db_name; 查看当前服务器版本SELECT VERSION();查看当前日期时间SELECT NOW(); 查看当前用户SELECT USER(); 查看用户当前打开的数据库SELECT DATABASE(); 2.数据类型与操作数据表 ¶2-1 数据类型 还有一种数据类型：日期时间型，实际工作中并不常用，这里就不做介绍 创建数据表：( column_name:列名称 、 data_type数据类型) CREATE TABLE [ IF NOT EXISTS ] tbl_name( column_name data_type, column_name data_type, … ); 创建数据表时还可以为字段指定某些属性例如： 无符号位（没有负数只有正数)UNSIGNED字段值可以为空 (不写默认可以为空)NULL字段值禁止为空NOT NULL AUTO_INCREMENT自动编号，且必须与主键组合使用，默认情况下，起始值为1，每次的增量为1 PRIMARY KEY主键约束每张数据表只能存在一个主键主键保证记录的唯一性主键自动为NOT NULL 注意: 自动编号必须和主键一起使用 但是主键不一定必须和自动编号一起使用 UNIQUE KEY唯一约束唯一约束可以保证记录的唯一性唯一约束的字段可以为空值（NULL）每张数据表可以存在多个唯一约束 DEFAULT默认约束默认值当插入记录时，如果没有明确为字段赋值，则自动赋予默认值 ¶2-2 操作数据表 查看数据表列表语法结构： SHOW TABLES [ FROM db_name ] [ LIKE ‘pattern’ | WHERE expr ]; SHOW TABLES;查看当前数据库当中的数据表列表SHOW TABLES FROM &nbsp;db_name;还可以查看其它数据库当中的数据表列表 插入记录： INSERT [INTO] tbl_name [(col_name,…)] VALUES(val,…) [(col_name,…)] 可以省略掉，但是省略掉就要为所有的列赋值 查看数据表结构SHOW COLUMNS FROM &nbsp;table_name； 丨 DESC &nbsp;table_name;查看表数据SELECT * FROM &nbsp;table_name;删除数据表DROP &nbsp;table_name; 3.总结 数据类型整型、浮点型、字符型、日期时间型数据表操作插入记录、查找记录记录操作创建数据表、约束的使用 未完待续。。。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yilia主题优化]]></title>
    <url>%2Farchives%2F8b232b37.html</url>
    <content type="text"><![CDATA[¶前言 hexo主题网站：https://hexo.io/themes/ 我试了好几个主题，有的不能用，有的不太好看，最后选择了yilia主题，这个挺好配的 yilia主题网址：https://github.com/litten/hexo-theme-yilia 要求node.js版本在6.2以上 ¶一、使用 安装 $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置 修改hexo根目录下的 _config.yml ： theme: yilia 更新 12cd themes/yiliagit pull ¶二、配置 主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 # Headermenu: 主页: / 随笔: /tags/随笔/ # SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml # 是否需要修改 root 路径 # 如果您的网站存放在子目录中，例如 http://yoursite.com/blog， # 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content # 文章太长，截断按钮文字excerpt_link: more # 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos; # 数学公式mathjax: false # 是否在新窗口打开链接open_in_new: false # 打赏 # 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2 # 打赏wordingreward_wording: &apos;谢谢你请我吃糖果&apos; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录 # 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1 # 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true # 目录为空时的提示toc_empty_wording: &apos;目录，不存在的…&apos; # 是否有快速回到顶部的按钮top: true # Miscellaneousbaidu_analytics: &apos;&apos;google_analytics: &apos;&apos;favicon: /favicon.png #你的头像urlavatar: #是否开启分享share_jia: true #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment #不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说duoshuo: false #2、网易云跟帖wangyiyun: false #3、畅言changyan_appid: falsechangyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false #5、Gitmentgitment_owner: false #你的 GitHub IDgitment_repo: &apos;&apos; #存储评论的 repogitment_oauth: client_id: &apos;&apos; #client ID client_secret: &apos;&apos; #client secret # 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: &apos;#4d4d4d&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos; # slider的设置slider: # 是否默认展开tags板块 showTags: false # 智能菜单 # 如不需要，将该对应项置为false # 比如 #smart_menu: # friends: falsesmart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos;friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家 具体参考原作者 ¶三、优化 ¶3.1、 所有文章功能不能用 node.js版本必须6.2以上 在hexo根目录下(注意不是yilia根目录)执行命令： npm i hexo-generator-json-content --save 在hexo的配置文件_config.yml最后添加 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 添加后 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 就行了 ¶3.2、 设置主页文章只显示一部分 这个只要在文章中加上&lt;!--more--标记 ，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。 这样每次添加这个标记有点麻烦，也可以自定义添加，不过可能会导致排版错乱，自定义配置链接 ¶3.3、 添加文章访问量统计 hexo添加访问量统计功能可以用百度的站长统计、leancloud，还有不蒜子，这里我用的不蒜子，感觉挺简单的。 引入不蒜子 &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 这段代码,我用的yilia主题，放在/themes/yilia/layout/_partial/footer.ejs 添加站点访问量 通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 计算访问量的方法有两种： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 我用的是uv的方式，大家自行选择即可。 添加文章访问量 文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签： 123&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 我们直接就这样放在yilia主题中，首页也会显示该网页的访问量，没法正常使用，所以我加一个判断，如果是首页不显示该文章的访问量，下面这段代码添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面： 12345&lt;% if ( !index )&#123; %&gt; &lt;span class=&quot;archive-article-date&quot;&gt; 阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&lt;% &#125; %&gt; ¶3.4、 设置网站小图标 到ico在线制作生成一个ico图片，命名为favicon.ico 然后把图标放在/themes/yilia/source/img里 然后设置yilia下的_config.yml的favicon: favicon.ico 然后更新github就行了 ¶3.5、 添加音乐 生成网易云音乐外链播放器 登录网页版网易云音乐，打开一首歌，点击 ”生成外链播放器“ 生产外链播放器代码，把代码粘贴到你想放的位置。 侧栏添加背景音乐 打开/hexo/themes/yilia/layout/_partial/left-col.ejs文件，把音乐HTML代码粘贴进去，可以添加样式，改变大小，这是我的代码： 1234567891011&lt;nav class=&quot;header-nav&quot;&gt; &lt;div class=&quot;social&quot;&gt; &lt;% for (var i in theme.subnav)&#123; %&gt; &lt;a class=&quot;&lt;%= i %&gt;&quot; target=&quot;_blank&quot; href=&quot;&lt;%- url_for(theme.subnav[i]) %&gt;&quot; title=&quot;&lt;%= i %&gt;&quot;&gt;&lt;i class=&quot;icon-&lt;%= i %&gt;&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;%&#125;%&gt; &lt;/div&gt; &lt;!--音乐播放插件--&gt; &lt;div style=&quot;margin-top:30px;&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=240 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=458639375&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/nav&gt; 在文章中添加音乐 配置hexo下的_config.yml的post_asset_folder: true 设置为true。 把音乐插件代码直接添加到文章中你想添加的位置就ok了。 ¶3.6、 很好玩的“小插件” 官网 这是一个能够实时统计访问你的站点或者博客的插件。 地球仪上的label表示访问站点的人的位置。 点击那个xxx visits，就会跳转到你的访问记录详情页了。 用法 1&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=5eb32qbhhbj&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 打开官网首页，在Get Started这里把这段js复制到你的网页上即可。 这里用的是hexo主题，我希望在左边栏显示，那么就找到/themes/hexo/layout/_partials/left-col.ejs,插入复制来的脚本即可。 参考 ¶3.7、 给博客增加动态标签 实现方式 打开博客路径themes/yilia/layout/layout.ejs 在前添加如下代码即可 1&lt;script type=&quot;text/javascript&quot;&gt;var OriginTitile=document.title,st;document.addEventListener(&quot;visibilitychange&quot;,function()&#123;document.hidden?(document.title=&quot;看不见我🙈~看不见我🙈~&quot;,clearTimeout(st)):(document.title=&quot;(๑•̀ㅂ•́) ✧被发现了～&quot;,st=setTimeout(function()&#123;document.title=OriginTitile&#125;,3e3))&#125;)&lt;/script&gt; ¶3.8、 图床推荐 →好用图床推荐 博主用的MoeTu图床、爱信息图床 具体根据个人爱好选择(建议使用https的) ¶3.9、 绑定个人域名 购买域名 国内的域名服务商有新网，腾讯云，还有阿里云的万网等。下面以阿里云的万网为例： 在万网购买了自己心仪的域名后，进入阿里云的管理控制台-域名与网站-域名就可以看到购买的域名此时的域名状态是未实名认证的，然后就是实名认证（一般需要2小时左右）。 域名解析 点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址， github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址， 两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。 然后打开你的github博客项目，点击settings 拉到下面Custom domain处，填上你自己的域名，保存 接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件 不带任何后缀，里面添加你的域名信息，如：qvchuang.top 实践证明如果此时你填写的是www.qvchuang.top那么以后你只能用www.qvchuang.top访问 而如果你填写的是qvchuang.top。那么用www.qvchuang.top和qvchuang.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。 ¶四、更多优化 更多参考 Hexo博客速度优化]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从用户登录测试谈起]]></title>
    <url>%2Farchives%2Feea48d79.html</url>
    <content type="text"><![CDATA[可能你会说，“用户登录”这个测试对象也有点太简单了吧。 我只要找一个用户，让他在界面上输入用户名和密码，然后点击“确认”按钮，验证一下是否登录成功就可以了。 的确，这构成了一个最基本、最典型的测试用例，这也是终端用户在使用系统时最典型的 Happy Pass 场景。 但是作为测试工程师，你的目标是要保证系统在各种应用场景下的功能是符合设计要求的，所以你需要考虑的测试用例就需要更多、更全面。 于是你可能会根据“用户登录”功能的需求描述，结合等价类划分和边界值分析方法来设计一系列的测试用例。 那什么是等价类划分和边界值分析方法呢？首先，这二者都隶属于最常用、最典型、也是最重要的黑盒测试方法。 等价类划分方法，是将所有可能的输入数据划分成若干个子集，在每个子集中，如果任意一个输入数据对于揭露程序中潜在错误都具有同等效果，那么这样的子集就构成了一个等价类。后续只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。 边界值分析方法，是选取输入、输出的边界值进行测试。因为通常大量的软件错误是发生在输入或输出范围的边界上，所以需要对边界值进行重点测试，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。 从方法论上可以看出来，边界值分析是对等价类划分的补充，所以这两种测试方法经常结合起来使用。 现在，针对“用户登录”功能，基于等价类划分和边界值分析方法，我们设计的测试用例包括： 输入已注册的用户名和正确的密码，验证是否登录成功； 输入已注册的用户名和不正确的密码，验证是否登录失败，并且提示信息正确； 输入未注册的用户名和任意密码，验证是否登录失败，并且提示信息正确； 用户名和密码两者都为空，验证是否登录失败，并且提示信息正确； 用户名和密码两者之一为空，验证是否登录失败，并且提示信息正确； 如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入正确的验证码，验证是否登录成功； 如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入错误的验证码，验证是否登录失败，并且提示信息正确； 列出这些测试用例后，你可能已经觉得比较满意了，因为你感觉已经把自己的测试知识都用在这些用例设计中了。 的确，上面的测试用例集已经涵盖了主要的功能测试场景。但是在一个优秀的测试工程师眼中，这些用例只能达到勉强及格的标准。 什么？才刚刚及格？如果你有这个想法，那我建议你在继续看下面的内容前，先仔细思考一下，这些测试用例是否真的还需要扩充。 现在，我跟你分享一下有经验的测试工程师会再增加的测试用例： 用户名和密码是否大小写敏感； 页面上的密码框是否加密显示； 后台系统创建的用户第一次登录成功时，是否提示修改密码； 忘记用户名和忘记密码的功能是否可用； 前端页面是否根据设计要求限制用户名和密码长度； 如果登录功能需要验证码，点击验证码图片是否可以更换验证码，更换后的验证码是否可用； 刷新页面是否会刷新验证码； 如果验证码具有时效性，需要分别验证时效内和时效外验证码的有效性； 用户登录成功但是会话超时后，继续操作是否会重定向到用户登录界面； 不同级别的用户，比如管理员用户和普通用户，登录系统后的权限是否正确； 页面默认焦点是否定位在用户名的输入框中； 快捷键 Tab 和 Enter 等，是否可以正常使用。 看完这些用例，你可能会说：“哇塞，原来一个简简单单的登录功能居然有这么多需要测试的点”。 但是，你别高兴得太早，“用户登录”功能的测试还没结束。 虽然改进后的测试用例集相比之前的测试覆盖率的确已经提高了很多，但是站在资深测试人员的角度来看，还有很多用例需要设计。 经我这么一说，你可能已经发现，上面所有的测试用例设计都是围绕显式功能性需求的验证展开的。 换句话说，这些用例都是直接针对“用户登录”功能的功能性进行验证和测试的。 但是，一个质量过硬的软件系统，除了显式功能性需求以外，其他的非功能性需求即隐式功能性需求也是极其关键的。 显式功能性需求（Functional requirement）的含义从字面上就可以很好地理解，指的是软件本身需要实现的具体功能， 比如“正常用户使用正确的用户名和密码可以成功登录”、“非注册用户无法登录”等，这都是属于典型的显式功能性需求描述。 那什么是非功能性需求（Non-functional requirement）呢？从软件测试的维度来看，非功能性需求主要涉及安全性、性能以及兼容性三大方面。 在上面所有的测试用例设计中，我们完全没有考虑对非功能性需求的测试，但这些往往是决定软件质量的关键因素。 明白了非功能性需求测试的重要性后，你可以先思考一下还需要设计哪些测试用例，然后再来看看我会给出哪些用例，相信这种方式对你的帮助会更大。 安全性测试用例包括： 用户密码后台存储是否加密； 用户密码在网络传输过程中是否加密； 密码是否具有有效期，密码有效期到期后，是否提示需要修改密码； 不登录的情况下，在浏览器中直接输入登录后的 URL 地址，验证是否会重新定向到用户登录界面； 密码输入框是否不支持复制和粘贴； 密码输入框内输入的密码是否都可以在页面源码模式下被查看； 用户名和密码的输入框中分别输入典型的“SQL 注入攻击”字符串，验证系统的返回页面； 用户名和密码的输入框中分别输入典型的“XSS 跨站脚本攻击”字符串，验证系统行为是否被篡改； 连续多次登录失败情况下，系统是否会阻止后续的尝试以应对暴力破解； 同一用户在同一终端的多种浏览器上登录，验证登录功能的互斥性是否符合设计预期； 同一用户先后在多台终端的浏览器上登录，验证登录是否具有互斥性。 性能压力测试用例包括: 单用户登录的响应时间是否小于 3 秒； 单用户登录时，后台请求数量是否过多； 高并发场景下用户登录的响应时间是否小于 5 秒； 高并发场景下服务端的监控指标是否符合预期； 高集合点并发场景下，是否存在资源死锁和不合理的资源等待； 长时间大量用户连续登录和登出，服务器端是否存在内存泄漏。 兼容性测试用例包括： 不同浏览器下，验证登录页面的显示以及功能正确性； 相同浏览器的不同版本下，验证登录页面的显示以及功能正确性； 不同移动设备终端的不同浏览器下，验证登录页面的显示以及功能正确性； 不同分辨率的界面下，验证登录页面的显示以及功能正确性。 说到这里，你还会觉得“用户登录”功能的测试非常简单、不值一提么？ 一个看似简单的功能测试，居然涵盖了如此多的测试用例，除了要覆盖明确的功能性需求，还需要考虑其他诸多的非功能性需求。 另外，通过这些测试用例的设计，你也可以发现， 一个优秀的测试工程师必须具有很宽广的知识面，如果你不能对被测系统的设计有深入的理解、不明白安全攻击的基本原理、没有掌握性能测试的基本设计方法，很难设计出“有的放矢”的测试用例。 通过“用户登录”功能测试这个实例，我希望可以激发你对测试更多的思考，并且开拓你设计测试用例的思路，以达到抛砖引玉的效果。 看完了这些测试用例，你可能会说还有一些遗漏的测试点没有覆盖到，这个功能的测试点还不够全面。那么，接下来我再跟你说说测试的不可穷尽性，即绝大多数情况下，是不可能进行穷尽测试的。 所谓的“穷尽测试”是指包含了软件输入值和前提条件所有可能组合的测试方法，完成穷尽测试的系统里应该不残留任何未知的软件缺陷。 因为如果有未知的软件缺陷，你可以通过做更多的测试来找到它们，也就是说你的测试还没有穷尽。 但是，在绝大多数的软件工程实践中，测试由于受限于时间成本和经济成本，是不可能去穷尽所有可能的组合的， 而是采用基于风险驱动的模式，有所侧重地选择测试范围和设计测试用例，以寻求缺陷风险和研发成本之间的平衡。 ¶总结 首先，对于高质量的软件测试，用例设计不仅需要考虑明确的显式功能性需求，还要涉及兼容性、安全性和性能等一系列的非功能性需求， 这些非功能性需求对软件系统的质量有着举足轻重的作用。 其次，优秀的测试工程师必须具有宽广的知识面，才能设计出有针对性、更易于发现问题的测试用例。 最后，软件测试的用例设计是不可穷尽的，工程实践中难免受制于时间成本和经济成本， 所以优秀的测试工程师需要兼顾缺陷风险和研发成本之间的平衡。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Web测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个bug的生命周期]]></title>
    <url>%2Farchives%2F65a189ea.html</url>
    <content type="text"><![CDATA[Bug的属性 Bug重现环境 这个应该是我们重现bug的一个前提，如果没有这个前提，我们可能会无法重现问题，或者跟本就无从下手。 操作系统 这个是一般软件运行的一大前提，基本上所有的软件都依赖于操作系统之上的，对于一个软件来说，要想在某个操作系统上运行，必须要对这个操作系统支持，这就需要有真对性的设计与开发。对于不同的操作系统，其可能存在差异（如：win xp 与 win 7）或本质的区别（如 win 7 与 CentOS linux ），所以，操作系统环境是重现问题的一个重要前提。 浏览器 对于B/S系统，或面向大众的互联网产品（网站，邮箱等），浏览器的兼容性也是必须测试的一个重点，对于现在的浏览器市场，各式的浏览器都有其用户群，要想使产品大众化，必须考虑这些产品的兼容性问题。 不同的浏览器之间（IE、 firefox、chrome、opera 等），甚至同一系列不同版本（ie6/ie7/ie8/ie9等）都可能存在兼容性问题，所以，对于这类应用，浏览器环境重现bug前提条件之一。 其它（这个“其它”非常重要） 对于不同的系统发现重现问题，都会有其特定的前提，拿我测试的邮箱来说，必须要描述其是在测试线还是现网环境，而且还要附带一重现问题的帐号等。 对于c/s软件，可能还要考虑与其它常用软的兼容等，例如，是在安装的某款软件后，对本软件的安装和使用造成影响。这些都是重现问题的必须描述的环境。 问题类型 根据JIRA的管理系统的划分，bug 只是问题的一种，它可以用于跟踪多种不同类型的问题（其实，他只是将bug做为一子类而已）。 JIRA系统缺省提供的问题类型（大部分的系统都可以自定义类型的，这样就增加了灵活性。） Bug : 测试过程、维护过程发现影响系统运行的缺陷。（这就是一般测试人员所提交的bug） New Feature : 对系统提出的新功能。（单个的小需求可以，如果大的话，就相当于一个需求，放到这里是不合理的。） Task : 需要完成的一任务。（开发或测试任务指派。） Improvement : 对现有系统功能的改进。（一般产品经理或产品体验师做的事） 当然，不同的公司，他们的人员定位与职责是不太相同的，按照上面的分类，JIRA就不是简单的缺陷管理系统了，它涵盖一项目（或产品）所需要处理的任务、需求与缺陷。 Bug 类型 这里缩小范围，单指我们测试人员在测试过程中发现的缺陷，发现产品缺陷其实就是测试人员工作的主要目的。当然，你要确定一个问题的类型，也需要对项目（或产品）有比较深的理解。是代码缺陷还是设计缺陷有时候就不太容易区分，当然，这个划分，对于开发定位问题影响很小，但对于问题类型的统计就比较重要了。 下面看一些常见的分类： 划分方式一： * 代码错误 * 设计缺陷 * 界面优化 * 配置相关 * 安装部署 * 性能问题 * 标准规范 * 测试代码 * 其它 划分方式二： * 功能类（function） * 性能类（performance） * 界面类（UI） * 易用性类（usability） * 兼容性类（compatibility） * 其它（else） 这个分类当然是可以自定义的，具我接触的缺陷管理都是可以自定义的，既然是对问题的管理，那么你当然可以拿来做特定环境下的系统来使用，或我就想用这个系统来指派任务，那么我的自定义类型为前端任务、后端任务、测试任务、配置部署… 缺陷等级 缺陷等级，这个划分也比较灵活，有分三级或四级，也有分五级的。 致命 一招毙命的缺陷，使你的系统无法运行，有造成数据泄漏的安全性问题。 严重 可以引起易于纠正的异常情况、可能引起易于修复的故障或对产品外观难以接受的缺陷。 一般 指不影响产品的运转和运行、不会成为故障起因，但对产品外观和下道工序影响较大的缺陷 轻微 轻微缺陷是指对产品外观和下道工序可能会有轻微影响的缺陷 建议 增加用户使用体验的建议性问题。（一般情况下，建议也为做为缺陷的一种。这个跟系统的类型与需求有关） 缺陷优先级（priority） 当问题处理人员在面对许多问题需要处理进，就需要问题进行优先级排序。我们做事情的安排，操作系统有处理进程等都在使用着优先级。 优先级的划分： 低——&gt;中——&gt;高——&gt;紧急 延迟处理——&gt;正常排队——&gt;优先处理——&gt;紧急处理 Bug的严重程度和优先级是含义不同但相互联系密切的两个概念，它们从不同的侧面描述了软件缺陷对软件质量和最终用户的影响程序和处理方式。 一般地，严重程序高的软件缺陷具有较高的优先级。严重程度高说明缺陷对软件造成的危害性大，需要优先处理，而来严重程序低的缺陷可能只是软件不太尽善尽美，可以稍后处理。 严重程度高优先级不一定高： 如果某个严重的软件缺陷只在非常极端的条件下产生，则没有必要马上处理。 如果某一个软件缺陷，需要重新修改软件的整体架构，可能会产生更多的潜在缺陷，而且软件由于市场的压力必须尽快发布，此时即使缺陷的严重性很高，是否需要修正，需要全盘考虑。 严重程度优先级不一定低 如果是软件名称或公司名称的拼写错误，虽然说其属于界面错误，严重程度不高，但其关系到软件和公司的市场开解，必须尽快修正。 缺陷状态 对于一个问题，其处理过程是一个周期，周期的不同阶段，其所处的状态也是不一样的。不同状态所对应的处理人也是不一样的。 打开： 表示问题被提交等待有人处理。 重新指派 ： 问题被重新指派给某人处理。 处理 ： 问题在处理中，尚未完成。 固定 ： 确认此问题存在，但暂时不进行处理。 回归 ： 对已经修复的问题进行回归确认。 关闭 ： 问题的最后一个状态。 一个bug的生命周期 下面通过一个比较完整的bug的处理流程图，更深刻的理解bug的状态以一个bug的生命周期。 提交（打开）缺陷 在提交一个缺陷的缺陷，首先尽量描述这个缺陷的属性。Bug重现环境，bug类型，bug等级，bug的优先级以及详细的重现步骤，结果与期望等。 当然，我们在提交一个问题之前首先应该保证，这个缺陷是没有被提过的，以免造成重复缺陷单。 如果是回归不通过的缺陷，其状态又会变为打开状态。 分配（转交）缺陷 这一步不是必须的，跟项目模式有关，有些公司测试部门与开发部门独立，那么测试人员就不确定自己测试的模块是由哪位开发人员负责的，在这种情况下，测试人员统一把问题指派给项目组长或经理，由项目组长（或经理）对问题进行确认后再次分配给相应的开发人员。 有些测试人员是穿插到不同研发团队中的，所以对不同的开人发员负责的开发模块非常清楚，这个时候就可以将问题直接指派给相应的开发人员。 也有一种情况，本来此问题应该由A开发人员负责，但由于A开发人员的调离或辞职，些问题为转交给其它人员处理。“分配”强调是上级对下级；“转交”强调的是平级之间。 确认缺陷 当开发人员接到一个缺陷时，首先是对其进行分析与重现，如果对其进行分析发现不是缺陷（可能由于测试人员不了解需求）或无法对此问题进行重现，那么就需要将此问题反回给测试人员，并注明原因。如果确认为缺陷则需要对其进行处理。 推迟处理 在处理问题之后，还需要进行一次判断，是否需要推迟处理，有些需求已经确认了是问题，由于其可能在极端情况下才会出现，或需要对系统架构进行改动，或其优先级非常低，所以暂时不需要对此问题进行处理（或到下个版本进再进行修复）。 固定 对于推迟处理的问题可以暂时进行固定（“固定”为QC中的叫法。）一般固定的问题需要经过项目经理与测试经理协商后才能固定。 处理缺陷 开发人员在确认完一个问题需要处理时，那么就对其进行处理工作。（例如，redmine 是支持处理人时时更新问题处理进度的，如 已处理30% ，已处理80% 等，当然，对于短时间内可以修复的问题就没必要时时的去更新处理进度。） 回归缺陷 回归缺陷对于测试人员来说是非常重要的工作，其有三个入口两个出口。 确认非缺陷问题：对于提交的一个缺陷，开人员处理为非问题或无法重现，然后直接转交给测试人员回归。测试人员再次确认，如果真如开发人员所说，则将问题关闭。如果非开发人员所说，是由于问题描述模糊或其它原因喂重现问题，则再次注明原因转给开发人员。 确认修复问题：对开发人员修复的问题再次进行确认，确认能过，则关闭问题。确认不通过，将问题再次打开并转给开发人员。 确认固定问题：有计划的对固定问题进行确认，有些固定问题随着时间的推移，版本的更新或已经不存在了，对这类问题应该及时关闭。有些固定问题依然存在且变得紧急，对于这类问题应该及时打开交给开发人员处理。 关闭缺陷 对于已经修复的缺陷进行关闭，这也是一个缺陷的最后一个状态。 最后，“状态”和“指派人”的对应关系如果更加细化，对项目而言是有益的： 已关闭---&gt;指派给修复这个bug的开发工程师。 无需解决，不是bug---&gt;指派给提交这个bug的测试人员。 无需解决，迭代待解决---&gt;指派给项目的产品经理。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Web测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例这件事儿]]></title>
    <url>%2Farchives%2F2e11eb3d.html</url>
    <content type="text"><![CDATA[1、测试用例的定义： 百度百科的解释是这样的：测试用例是为某个特殊目标而编制的一组输入、执行条件以及预期结果，以便 测试某个程序路径或者合适是否满足特定需求 俗话理解：通过一组输入输出来验证某个需求的状态或者结果是否满足预定结果 2、测试用例的好处： A、有效、快速的了解待测需求 B、测试用例的编写、执行数量可以评估需求的覆盖度 C、测试用例的细化程度、可以作为阶段性工作的排期的依据 D、测试用例的输出可以将人为因素的影响减少，如a同学编写用例后，b同学可以依据用例进行执行功能 总结：思路清晰、避免遗漏、跟进测试进度、历史数据参考、避免重复性劳动 3、何时开始设计测试用例？ 需求文档定版后，即可开始陈列测试点和编写测试用例 4、如何设计测试用例？ A、首先将需求文档或者产品文档中的规则转述为每个用例的检查点 B、单个用例最小化原则，即一条用例只做一件事 C、先从单个模块或者功能点入手写用例 D、借助常用的测试用例设计方法，如等价类、边界值、因果图等 总结： n1：除了上诉的内容外，还需要考虑兼容性问题、浏览器兼容性、操作系统兼容性，如果是app侧的还要 考虑中断测试、弱网测试等等 n2：设计测试用例时也要注意涉及到的数据库中的字段值是否正确 n3：需要注意关联模块的用例设计 n4：注意新增接口、新增字段的用例的设计 5、实际工作中如何设计用例？ A、根据需求文档找到角色和功能模块的匹配关系，输出Usecase图 B、输出流程图（如果产品有输出流程图那是最好的了，没有只能测试自己输出流程图，并发给产品进行 查缺补漏） C、依据业务规则、UseCase、流程图输出测试用例 6、测试用例的评审与更新？ 测试用例是一定要评审的，因为每个人都有自己的测试盲区，所以不要认为自己考虑的是全面的 评审参与人员，相关产品、开发、测试参与即可 评审的意义：将测试用例编写中遇到的疑问在此得到答案，并引导开发、产品功能进行思考补充现有用例（查缺补漏） 测试用例更新：一是评审后需要更新，在者就是测试过程中需要更新，测试结束后根据线上反馈情况进行更新 7、所有项目都需要写测试用例么？ 测试用例的编写需要根据待测试任务的大小、紧急程度、测试人员数量等多方面衡量 对于大中型任务，个人建议还是要写详细的用例，因为写用例就是思考的过程 对于紧急小型任务，可以写测试点 对于新人负责的模块，一定要写测试用例（本人写或者老人写完，新人执行） 8、测试用例的颗粒度？ 其实和问题7有一定的关联，在问题7的前提下，仅仅就测试人员来说是否写测试用例，写何种颗粒度的测试用例其实取 决于测试人员本身的水平 如何写用例、怎么写、写到何种粒度都需要依据当前公司的项目的情况决定。 但是依旧建议无论测试人员本身水平如何，都需要输出基本的测试用例或者测试点。 首先这是对自己的负责，其次随着时间的流逝，你能保证记录下曾经所有的用例么， 这也就是为何建议输出用例或者测试点的原因，不要认为测试用例的设计没有任何的含量， 恰恰相反，测试用例的设计反而是最核心的技能。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试用例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所谓安逸。。。。。。]]></title>
    <url>%2Farchives%2F9c44ad68.html</url>
    <content type="text"><![CDATA[你所谓的安逸，正在慢慢毁掉你！ 01 “我是刚毕业的学生，来北京随便找了个工作一年多，因为自己情商低还是什么原因，在公司一直得不到认可，感觉很没有成就感， 又觉得前途一片迷茫，可以麻烦您说一下您的建议吗？” 前些天，有一位读者给我留言。我回她“先干好活儿，和同事领导搞好关系，学习PPT、英语等新技能。” 后来她又告诉我，她25岁，目前她在北京的一家自考培训机构上班，主要做的工作就是课程销售，每天给人打电话，然后解答一些 自考者的咨询，经常加班，工资6000元，她感觉说不到什么东西，一直就是这样耗着。 她不敢辞职，因为一个人在北京，怕遇到坏人。 “你不喜欢现在的工作，那可以在8小时之外学习一些新的知识，投资自己，给自己的职场加码，即使你走出这家公司，可以找到更好 的公司。”我这样建议。 她回了一句“每天都忙死了，没有时间去学习”。 02 L先生名校毕业，在大学的时候成绩突出，年年拿奖学金。毕业的时候找工作很顺利，来到了一家上海的企业做机械设计。 转眼他在这家企业已经工作6年了，这期间工资没有涨多少。 最近一次还是去年，涨了1000元左右。 上海工资普遍比较高，每次回家过年，亲戚朋友问他这么多年了工资应该每个月2、3万了，他都闭口不谈应付过去，因为他清楚上班六年 工资只有8000元，在行业里算低的。 L先生也尝试过学习一些新的技能，考了证券师打算做兼职，可是这两年金融行业不景气，他没有赚到多少钱。 “在上海这座寸土寸金的城市，每个企业都在竞争，每个人都是快节奏的，可是这家企业一周工作五天，每天下午4点多就下班了，这是 不正常的。年轻人在这样的企业里刚开始能学到东西，但是太安逸了，慢慢的会成为温水里的青蛙”一个企业的高管说。 眼看着其他的同事跳槽到外企或者别的企业，工资翻番；眼看着曾经一块毕业的同学都年薪30多万甚至更多，买了房买了车，而他还依旧 待在这家企业里面，只是一个普通的工程师。 朋友建议他先试着把简历放出来，试着给自己一些新工作的面试机会，毕竟面试也是需要准备的。 如果你懈怠了，就把简历拿到市场上，让它来衡量一下自己的价值，到底是贬值了还是增值了。 03 在知乎上看过一个问题：“你见过最不求上进的人是什么样子？” 点赞数第一的回答是： “我见过的最不求上进的人，他们为现状焦虑，又没有毅力践行决心去改变自己。 三分钟热度，时常憎恶自己的不争气，坚持最多的事情就是坚持不下去。 终日混迹社交网络，脸色蜡黄地对着手机和电脑的冷光屏，可以说上几句话的人却寥寥无几。 他们以最普通的身份埋没在人群中，却过着最最煎熬的日子。” 在现实生活中，这样的普通人挺多的，上班的时候侃大山，下班的时候就胡吃海喝或者打游戏。 每天手机不离手，慢着刷微博、朋友圈，一个短视频刷过去一两个小时就过去了。10点多该睡觉了，手机还不肯放下，不知不觉到凌晨了， 美其名曰“夜猫子型”，第二天有时7点多才起床，赶着去上班，偶尔还会迟到被老板训。 周末的时候宅在家，没有兴趣与爱好，葛优躺一天就过去了。 好久不读书了，健身房不去了，说好的坚持早起也起不来，人变胖了、肚子赘肉又多了一圈，每天慢慢碌碌过完一天，也不曾想过这一天收获什么。 原来的你激情满满，“我辈岂是蓬蒿人，直挂云帆济沧海”。 现在的你得过且过，“老婆孩子热炕头，过了一天少三晌”。 你也曾为生活焦虑，工资低、没对象、身体发福、年纪增长、20岁就能看到60岁的生活。 可是你太安逸了，然后慢慢的停止了奋斗，找不到方向，成为你曾经讨厌的样子。 04 电影《解忧杂货店》里面有一段故事，20年前，孤儿出身的一个女孩因为生活所迫做了舞女，收入还可以，但是在人看来出卖了尊严，挥霍着青春。后来还 差点被骗子骗，人财两空。 她把情况写了一封信，对方告诉她做舞女不是长久之计，一定要改变。 于是她在20岁的时候选择重新开始上课，好好学习，学习会计、学英语、考大学，靠着努力、不断积累财富，最后成为一个女企业家，并帮助曾经帮助过自己的人 还有那所叫“彩虹之家”的孤儿院。 **你可能说这是电影，可是现实告诉放弃安逸改变自己不会错。 ** G小姐大学学的是营销，后来工作的时候接触到服装行业。 上班前两年，她天天加班、出差，非常的辛苦，升职加薪也比较遥远，因为做销售的人员太多了，她意识到必须掌握行业核心的技能才能让自己脱颖而出。 于是她开始学习绘画、学习服装设计的知识，从小白花了两年时间已经成为服装设计师，对任何服装品牌、对各种设计元素都了如指掌，这帮助她很快升为主管， 再后来跳槽出来已经成为某服装品牌的大区运营负责人，年薪几十万。 05 你说想考招教，普通话不好，为什么不练习？ 你说想减肥，已经胖了20斤，为什么不去减肥？ 你想考研，成为名校的研究生，为什么不去自习室看书？ … 你安逸到无法改变，成为所谓“佛系青年”。 你常常把“努力不一定成功，但不努力会很轻松”挂在嘴边。 可是你真的觉得这样的轻松是轻松吗？当你离开学校的时候，你凭什么找到一份更好工作？当父母老了，你靠什么赡养他们？当孩子大了，你能不能让他和其他 孩子一样享受到好的教育？当你生病了会不会让生活回到解放前？ … 我看到很多身边的朋友，即使已经有了稳定的工作，职称和级别，但还在努力的学习，通过考试、读书、运动、培养兴趣爱好等方式提升自己。 他们说，奋斗时光才是美好的。 拼命的奔跑的人一定比停下来的人走的更远。 年轻，只有那么短短的一二十年，你可以选择安逸，但是我相信更多的人会选择按照自己想要的方式燃一次。 **停止打游戏、停止熬夜、停止无效的社交。 ** **在没有人看到的地方去努力，坚持早起、坚持学习、坚持运动，不断学习新技能，努力遇见更好的自己。 ** 优秀的人之所以优秀，是因为他们从未停止奋斗，从未因生活的不如意过早的放弃！ 永远在路上，为了自己的目标，选择了自己要走的路，再难也要走下去。 永远在路上，千万不要太安逸而过早放弃，即使生活蹉跎，但内心依旧有光，努力蜕变继而绽放自己！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web测试到底是在测什么]]></title>
    <url>%2Farchives%2Fb81d1284.html</url>
    <content type="text"><![CDATA[开始主题之前先来看一张图 Web测试 进行抽离拆分，基本上就如上一些内容。 不管是测什么系统，什么功能，基本都差不多。 唯一区别是，一些特性 &amp; 细节 OK ，正式开始今日的主题 ： 如下，是摘自网络的Web通用测试点； 这类内容，网上随处一搜大把。 ¶一、输入框 1、字符型输入框： （1）字符型输入框：英文全角、英文半角、数字、空或者空格、特殊字符“~！@#￥%……&amp;*？[]{}”特别要注意单引号和&amp;符号。禁止直接输入特殊字符时，使用“粘贴、拷贝”功能尝试输入。 （2）长度检查：最小长度、最大长度、最小长度-1、最大长度+1、输入超工字符比如把整个文章拷贝过去。 （3）空格检查：输入的字符间有空格、字符前有空格、字符后有空格、字符前后有空格 （4）多行文本框输入：允许回车换行、保存后再显示能够保存输入的格式、仅输入回车换行，检查能否正确保存（若能，检查保存结果，若不能，查看是否有正常提示） （5）安全性检查：输入特殊字符串（null,NULL,javascript…）、输入脚本函数(alert(“abc”))、doucment.write(“abc”)、hello） 2、数值型输入框： （1）边界值：最大值、最小值、最大值+1、最小值-1 （2）位数：最小位数、最大位数、最小位数-1最大位数+1、输入超长值、输入整数 （3）异常值、特殊字符：输入空白（NULL）、空格或&quot;~!@#$%^&amp;*()_+{}|[]:&quot;&lt;&gt;?;’,./?;:’-=等可能导致系统错误的字符、禁止直接输入特殊字符时，尝试使用粘贴拷贝查看是否能正常提交、word中的特殊功能，通过剪贴板拷贝到输入框，分页符，分节符类似公式的上下标等、数值的特殊符号如∑，㏒，㏑，∏，+，-等、 输入负整数、负小数、分数、输入字母或汉字、小数（小数前0点舍去的情况，多个小数点的情况）、首位为0的数字如01、02、科学计数法是否支持1.0E2、全角数字与半角数字、数字与字母混合、16进制，8进制数值、货币型输入（允许小数点后面几位） （4）安全性检查：不能直接输入就copy 3、日期型输入框： （1）合法性检查：(输入0日、1日、32日)、月输入[1、3、5、7、8、10、12]、日输入[31]、月输入[4、6、9、11]、日输入[30][31]、输入非闰年，月输入[2]，日期输入[28、29]、输入闰年，月输入[2]、日期输入[29、30]、月输入[0、1、12、13] (2)异常值、特殊字符：输入空白或NULL、输入~！@#￥%……&amp;*（）{}[]等可能导致系统错误的字符 （3）安全性检查：不能直接输入，就copy，是否数据检验出错？ 4、信息重复:在一些需要命名,且名字应该唯一的信息输入重复的名字或ID,看系统有没有处理,会否报错,重名包括是否区分大小写,以及在输入内容的前后输入空格,系统是否作出正确处理. ¶二、搜索功能 若查询条件为输入框，则参考输入框对应类型的测试方法 1、功能实现： （1）如果支持模糊查询，搜索名称中任意一个字符是否能搜索到 （2）比较长的名称是否能查到 （3）输入系统中不存在的与之匹配的条件 （4）用户进行查询操作时，一般情况是不进行查询条件的清空，除非需求特殊说明。 2、组合测试： （1）不同查询条件之间来回选择，是否出现页面错误（单选框和多选框最容易出错） （2）测试多个查询条件时，要注意查询条件的组合测试，可能不同组合的测试会报错。 ¶三、添加、修改功能 1、特殊键： （1）是否支持Tab键 （2）是否支持回车键 2、提示信息： （1）不符合要求的地方是否有错误提示 3、唯一性： 字段唯一的，是否可以重复添加，添加后是否能修改为已存在的字段（字段包括区分大小写以及在输入的内容前后输入空格，保存后，数据是否真的插入到数据库中，注意保存后数据的正确性） 4、数据 正确性： （1）对编辑页的每个编辑项进行修改，点击保存，是否可以保存成功，检查想关联的数据是否得到更新。 （2）进行必填项检查（即是否给出提示以及提示后是否依然把数据存到数据库中；是否提示后出现页码错乱等） （3）是否能够连续添加（针对特殊情况） （4）在编辑的时候，注意编辑项的长度限制，有时在添加的时候有，在编辑的时候却没有（注意要添加和修改规则是否一致） （5）对于有图片上传功能的编辑框，若不上传图片，查看编辑页面时是否显示有默认的图片，若上传图片，查看是否显示为上传图片 （6）修改后增加数据后，特别要注意查询页面的数据是否及时更新，特别是在首页时要注意数据的更新。 （7）提交数据时，连续多次点击，查看系统会不会连续增加几条相同的数据或报错。 （8）若结果列表中没有记录或者没选择某条记录，点击修改按钮，系统会抛异常。 ¶四、删除功能 1、特殊键： （1）是否支持Tab键 （2）是否支持回车键 2、提示信息： （1）不选择任何信息，直接点击删除按钮，是否有提示 （2）删除某条信息时，应该有确认提示 3、数据 实现： （1）是否能连续删除多个产品 （2）当只有一条数据时，是否可以删除成功 （3）删除一条数据后，是否可以添加相同的数据 （4）如系统支持批量删除，注意删除的信息是否正确 （5）如有全选，注意是否把所有的数据删除 （6）删除数据时，要注意相应查询页面的数据是否及时更新 （7）如删除的数据与其他业务数据关联，要注意其关联性（如删除部门信息时，部门下游员工，则应该给出提示） （8）如果结果列表中没有记录或没有选择任何一条记录，点击删除按钮系统会报错。 ¶五、注册、登陆模块 1、注册功能： （1）注册时，设置密码为特殊版本号，检查登录时是否会报错 （2）注册成功后，页面应该以登陆状态跳转到首页或指定页面 （3）在注册信息中删除已输入的信息，检查是否可以注册成功。 2、登陆 功能： （1）输入正确的用户名和正确的密码 （2）输入正确的用户名和错误的密码 （3）输入错误的用户名和正确的密码 （4）输入错误的用户名和错误的密码 （5）不输入用户名和密码（均为空格） （6）只输入用户名，密码为空 （7）用户名为空，只输入密码 （8）输入正确的用户名和密码，但是不区分大小写 （9）用户名和密码包括特殊字符 （10）用户名和密码输入超长值 （11）已删除的用户名和密码 （12）登录时，当页面刷新或重新输入数据时，验证码是否更新 ¶六、上传功能 1、功能 实现： （1）文件类型正确、大小合适 （2）文件类型正确，大小不合适 （3）文件类型错误，大小合适 （4）文件类型和大小都合适，上传一个正在使用中的图片 （5）文件类型大小都合适，手动输入存在的图片地址来上传 （6）文件类型和大小都合适，输入不存在的图片地址来上传 （7）文件类型和大小都合适，输入图片名称来上传 （8）不选择文件直接点击上传，查看是否给出提示 （9）连续多次选择不同的文件，查看是否上传最后一次选择的文件 ¶七、查询结果列表 1、功能 实现： （1）列表、列宽是否合理 （2）列表数据太宽有没有提供横向滚动 （3）列表的列名有没有与内容对应 （4）列表的每列的列名是否描述的清晰 （5）列表是否把不必要的列都显示出来 （6）点击某列进行排序，是否会报错（点击查看每一页的排序是否正确） （7）双击或单击某列信息，是否会报错 ¶八、返回键检查 1、一条已经成功提交的记录，返回后再提交，是否做了处理 2、检查多次使用返回键的情况，在有返回键的地方，返回到原来的页面多次，查看是否会出错 ¶九、回车键检查 在输入结果后，直接按回车键，看系统如何处理，是否会报错 ¶十、刷新键检查 在Web系统中，使用刷新键，看系统如何处理，是否会报错 ¶十一、直接URL链接检查 在Web系统中，在地址栏直接输入各个功能页面的URL地址，看系统如何处理，是否能够直接链接查看（匿名查看），是否有权限控制，是否直接执行，并返回相应结果页； ¶十二、界面和易用性测试 1、风格、样式、颜色是否协调 2、界面布局是否整齐、协调（保证全部显示出来的，尽量不要使用滚动条 3、界面操作、标题描述是否恰当（描述有歧义、注意是否有错别字） 4、操作是否符合人们的常规习惯（有没有把相似的功能的控件放在一起，方便操作） 5、提示界面是否符合规范（不应该显示英文的cancel、ok，应该显示中文的确定等） 6、界面中各个控件是否对齐 7、日期控件是否可编辑 8、日期控件的长度是否合理，以修改时可以把时间全部显示出来为准 9、查询结果列表列宽是否合理、标签描述是否合理 10、查询结果列表太宽没有横向滚动提示 11、对于信息比较长的文本，文本框有没有提供自动竖直滚动条 12、数据录入控件是否方便 13、有没有支持Tab键，键的顺序要有条理，不乱跳 14、有没有提供相关的热键 15、控件的提示语描述是否正确 16、模块调用是否统一，相同的模块是否调用同一个界面 17、用滚动条移动页面时，页面的控件是否显示正常 18、日期的正确格式应该是XXXX-XX-XX或XXXX-XX-XX XX:XX:XX 19、页面是否有多余按钮或标签 20、窗口标题或图标是否与菜单栏的统一 21、窗口的最大化、最小化是否能正确切换 22、对于正常的功能，用户可以不必阅读用户手册就能使用 23、执行风险操作时，有确认、删除等提示吗 24、操作顺序是否合理 25、正确性检查：检查页面上的form, button, table, header, footer,提示信息，还有其他文字拼写，句子的语法等是否正确。 26、系统应该在用户执行错误的操作之前提出警告，提示信息. 27、页面分辨率检查，在各种分辨率浏览系统检查系统界面友好性。 28、合理性检查：做delete, update, add, cancel, back等操作后，查看信息回到的页面是否合理。 29、检查本地化是否通过：英文版不应该有中文信息，英文翻译准确，专业。 ¶十三、兼容性测试 兼容性测试不只是指界面在不同操作系统或浏览器下的兼容，有些功能方面的测试，也要考虑到兼容性， 包括操作系统兼容和应用软件兼容，可能还包括硬件兼容 比如涉及到ajax、jquery、javascript等技术的，都要考虑到不同浏览器下的兼容性问题。 ¶十四、链接测试 主要是保证链接的可用性和正确性，它也是网站测试中比较重要的一个方面。 可以使用特定的工具如XENU来进行链接测试。 1 导航测试 导航描述了用户在一个页面内操作的方式，在不同的用户接口控制之间，例如按钮、对话框、列表和窗口等；或在不同的连接页面之间。通过考虑下列问题，可以决定一个Web应用系统是否易于导航：导航是否直观？Web系统的主要部分是否可通过主页存取？Web系统是否需要站点地图、搜索引擎或其他的导航帮助？ 在一个页面上放太多的信息往往起到与预期相反的效果。Web应用系统的用户趋向于目的驱动，很快地扫描一个Web应用系统，看是否有满足自己需要的信息，如果没有，就会很快地离开。很少有用户愿意花时间去熟悉Web应用系统的结构，因此，Web应用系统导航帮助要尽可能地准确。 导航的另一个重要方面是Web应用系统的页面结构、导航、菜单、连接的风格是否一致。确保用户凭直觉就知道Web应用系统里面是否还有内容，内容在什么地方。 Web应用系统的层次一旦决定，就要着手测试用户导航功能，让最终用户参与这种测试，效果将更加明显。 2 图形测试 在Web应用系统中，适当的图片和动画既能起到广告宣传的作用，又能起到美化页面的功能。一个Web应用系统的图形可以包括图片、动画、边框、颜色、字体、背景、按钮等。图形测试的内容有： （1）要确保图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间。Web应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面。 （2）验证所有页面字体的风格是否一致。 （3）背景颜色应该与字体颜色和前景颜色相搭配。 （4）图片的大小和质量也是一个很重要的因素，一般采用JPG或GIF压缩，最好能使图片的大小减小到30k以下 （5）最后，需要验证的是文字回绕是否正确。如果说明文字指向右边的图片，应该确保该图片出现在右边。不要因为使用图片而使窗口和段落排列古怪或者出现孤行。 通常来说，使用少许或尽量不使用背景是个不错的选择。如果您想用背景，那么最好使用单色的，和导航条一起放在页面的左边。另外，图案和图片可能会转移用户的注意力。 ¶十五、业务流程测试（主要功能测试） 业务流程，一般会涉及到多个模块的数据，所以在对业务流程测试时，首先要保证单个模块功能的正确性，其次就要对各个模块间传递的数据进行测试，这往往是容易出现问题的地方，测试时一定要设计不同的数据进行测试。 ¶十六、安全性测试 （1）SQL注入（比如登陆页面） （2）XSS跨网站脚本攻击：程序或数据库没有对一些特殊字符进行过滤或处理，导致用户所输入的一些破坏性的脚本语句能够直接写进数据库中，浏览器会直接执行这些脚本语句，破坏网站的正常显示，或网站用户的信息被盗,构造脚本语句时，要保证脚本的完整性。 document.write(“abc”) alter(“abc”) （3）URL地址后面随便输入一些符号，并尽量是动态参数靠后 （4）验证码更新问题 （5）现在的Web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等。 （6）Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内（例如15分钟）没有点击任何页面，是否需要重新登陆才能正常使用。 （7）为了保证Web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。 （8）当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。 （9）服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。 ¶十七、性能测试 1 连接速度测试 用户连接到Web应用系统的速度根据上网方式的变化而变化，他们或许是电话拨号，或是宽带上网。当下载一个程序时，用户可以等较长的时间，但如果仅仅访问一个页面就不会这样。如果Web系统响应时间太长（例如超过5秒钟），用户就会因没有耐心等待而离开。 另外，有些页面有超时的限制，如果响应速度太慢，用户可能还没来得及浏览内容，就需要重新登陆了。而且，连接速度太慢，还可能引起数据丢失，使用户得不到真实的页面。 2 负载测试 负载测试是为了测量Web系统在某一负载级别上的性能，以保证Web系统在需求范围内能正常工作。负载级别可以是某个时刻同时访问Web系统的用户数量，也可以是在线数据处理的数量。例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？ 3 压力测试 负载测试应该安排在Web系统发布以后，在实际的网络环境中进行测试。因为一个企业内部员工，特别是项目组人员总是有限的，而一个Web系统能同时处理的请求数量将远远超出这个限度，所以，只有放在Internet上，接受负载测试，其结果才是正确可信的。 进行压力测试是指实际破坏一个Web应用系统，测试系统的反映。压力测试是测试系统的限制和故障恢复能力，也就是测试Web应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到Web应用系统崩溃，接着当系统重新启动时获得存取权。 压力测试的区域包括表单、登陆和其他信息传输页面等。 备注： 1、负载/压力测试应该关注什么 测试需要验证系统能否在同一时间响应大量的用户，在用户传送大量数据的时候能否响应，系统能否长时间运行。可访问性对用户来说是极其重要的。如果用户得到“系统忙”的信息，他们可能放弃，并转向竞争对手。系统检测不仅要使用户能够正常访问站点，在很多情况下，可能会有黑客试图通过发送大量数据包来攻击服务器。出于安全的原因，测试人员应该知道当系统过载时，需要采取哪些措施，而不是简单地提升系统性能。 1）瞬间访问高峰 如果您的站点用于公布彩票的抽奖结果，最好使系统在中奖号码公布后的一段时间内能够响应上百万的请求。负载测试工具能够模拟X个用户同时访问测试站点。 2）每个用户传送大量数据 网上书店的多数用户可能只订购1-5书，但是大学书店可能会订购5000本有关心理学介绍的课本?或者一个祖母为她的50个儿孙购买圣诞礼物(当然每个孩子都有自己的邮件地址)系统能处理单个用户的大量数据吗? 3）长时间的使用 如果站点用于处理鲜花订单，那么至少希望它在母亲节前的一周内能持续运行。如果站点提供基于web的email服务，那么点最好能持续运行几个月，甚至几年。可能需要使用自动测试工具来完成这种类型的测试，因为很难通过手工完成这些测试。你可以想象组织100个人同时点击某个站点。但是同时组织100000个人呢。通常，测试工具在第二次使用的时候，它创造的效益，就足以支付成本。而且，测试工具安装完成之后，再次使用的时候，只要点击几下。 采取措施：采用性能测试工具WAS、ACT，LR等协助进行测试 ¶十八、测试中应该注意的其他情况 1、在测试时，与网络有关的步骤或者模块必须考虑到断网的情况 2、每个页面都有相应的Title，不能为空，或者显示“无标题页” 3、在测试的时候要考虑到页面出现滚动条时，滚动条上下滚动时，页面是否正常 4、URL不区分大小写，大小写不敏感 5、对于电子商务网站，当用户并发购买数量大于库存的数量时，系统如何处理 6、测试数据避免单纯输入“123”、“abc“之类的，让测试数据尽量接近实际 7、进行测试时，尽量不要用超级管理员进行测试，用新建的用户进行测试。测试人员尽量不要使用同一个用户进行测试 8、提示信息：提示信息是否完整、正确、详细 9、帮助信息：是否提供帮助信息，帮助信息的表现形式（页面文字、提示信息、帮助文件），帮助信息是否正确、详细 10、可扩展性：是否由升级的余地，是否保留了接口 11、稳定性：运行所需的软硬件配置，占用资源情况，出现问题时的容错性，对数据的保护 12、运行速度：运行的快慢，带宽占用情况 补充几点： 针对上面的摘录，补充如下几个点。 分页功能 通用测试点：未满一页，多页，页面跳转，首页，尾页，上一页/下一页，每页显示页数，等等。 导出功能 通用测试点：文件格式，数据量，表头，数据正确性 等。 第三方登录 通用测试点：绑定已有账号，识别唯一标识等。 继续，补充： web测试需要了解的知识 HTTP/HTTPS协议 你应该去了解什么是http协议 什么是GET, POST, session, cookie等 Get与Post的区别是什么? session与cookie的区别是什么? 什么是无状态？ 注：http这块，之前分享过资料，回复“http”获取 浏览器机制 理解浏览器在处理javascript及渲染CSS的机制 了解IE与其他浏览器的差异 同一浏览器，各版本的区别。 浏览器在加载javascript，CSS有时在前面有时在后面，为什么？ 加载顺序会对视觉和使用上有什么影响呢？ 各种浏览器使用的内核分别是什么？ web架构 也许你会说这是架构师的事儿，没错，基本是他们的活儿，但是理解了web架构能让我们测试的更深入。你要知道： 软件出错时怎么个报警法？是否有详尽的log记录？ 服务器缓存机制如何？ 数据库如何主从同步，如何备份的？ 集群如何处理session的？ 安全 因为web应用的特殊性，你需要掌握的安全技能： 如何进行SQL注入测试？如何防止SQL注入？ 什么是跨站脚本攻击(XSS)？如何开展此类测试，应该如何防范XSS？ 什么是DOS，DDOS？开发人员如何coding来避免？ 传输哪些重要数据时需要加密 哪些页面需要使用SSL/https来加密传输 什么是跨站伪造请求攻击 cross site request forgeries (XSRF)，如何避免？ 安全证书的意义，浏览器在证书失效时提示是怎样的？ web性能 你应该知道的web性能知识： web前端的性能极大影响了用户，如何观察这些数据？CSS和图片的合并压缩的意义 了解浏览器cache及服务端cache 对于图片请求过多的网站，为何要把图片放置在不同的域名下，最好使用CDN？ 确认你的网站有一个 favicon.ico 文件放在网站的根下，如 /favicon.ico.每当有用户收藏网站/网页时，浏览器会自动请求这个文件，就算这个图标文件没有在你的网页中明显说明，浏览器也会请求。如果你没有这个文件，就会出大量的404错误，这会消耗你的服务器带宽，服务器返回404页面会比这个ico文件可能还大 知道单个页面的http请求数越少越好 顺序加载和异步加载的优劣，何时需要使用AJAX？懒加载的意义，用于何处？ 如何使用性能测试工具Jmeter/LR等开展性能测试？ 用户体验 网站的功能只是说实现了什么，而用户体验则诠释了做的有多好，用户使用起来是否有难度，是否会爱上这个网站（当然12306除外，咯咯） 访问网站的用户操作行为是怎么样的？页面的访问频率占比如何？因为测试的精力和侧重点也要根据这个数据而定 网站部署时是否会影响到用户使用，如何避免？ 不要直接显示不友好的错误提示，是否有友好的提示信息？ web应用不能泄漏用户的隐私信息 页面是在当前页打开还是另开一个tab？ 页面元素的布局如何影响到用户体验的？ 使用工具 HttpWatch，基于IE的网络数据分析工具，包括网页摘要，Cookies管理，缓存管理，消息头发送/接受，字符查询，POST 数据和目录管理功能等 FireBug，用途同上，基于firefox的 Yslow，前端网站性能工具，显示测试结果的分析,分为等级、组件、统计信息 Fiddler，强大的web前端调试工具，它能记录/拦截所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据，也可用于安全测试 Chrome扩展程序：浏览器兼容性检测工具，分析网站的兼容性情况 轻量级压力测试工具 性能测试工具，不只是LoadRunner \ Jmeter 还有很多优秀的小工具，而且学习成本非常低，随时上手～ 今天推荐几款web轻量级压力测试小工具，人人可以做压力测试，而且瞬间上手，无学习成本～ 推荐一：webbench 推荐二：ab 推荐三：http_load 推荐四：siege]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Web测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter]]></title>
    <url>%2Farchives%2F8722731a.html</url>
    <content type="text"><![CDATA[Jmeter ¶环境搭建及安装 Jmeter新手教程]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo＋Github搭建博客]]></title>
    <url>%2Farchives%2F51de246d.html</url>
    <content type="text"><![CDATA[前言：电脑系统为window 10专业版，64位 相关步骤： ¶1、安装Git和配置好Git环境 安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 ¶2、安装Node.js和配置好Node.js环境 打开cmd命令行，成功界面如下 ¶3、Github账户注册和新建项目 项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 ¶4、安装Hexo 在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 ¶5、将Hexo与Github page联系起来 设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “xxxxxxxxx@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pair ssh-add -D rm -r ~/.ssh 删除你在github中的public-key 重新生成ssh密钥对 ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 接下来正常操作,在github上添加公钥public-key: 1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板 2、在github上添加公钥时，直接复制即可 3、保存 测试： 在终端 ssh -T git@github.com ¶6、配置Deployment 在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） ¶7、生成以及部署文章 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save 新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 使用编辑器编好文章，那么就可以使用命令： Markdown语法 hexo g 生成网站静态文件 hexo s 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ hexo d 自动生成网站静态文件，并部署到设定的仓库。 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。 ¶双部署 将 Hexo 个人博客同时部署到 GitHub 和 Coding 上 ¶其它 换了新电脑，需要在新电脑上进行部署Hexo ¶借鉴 Hexo+GitHub搭建教程 nexT主题个性化配置教程 Hexo博客搭建教程 Hexo博客搭建教程 hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
